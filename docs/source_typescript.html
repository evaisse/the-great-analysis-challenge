<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typescript Source Code - The Great Analysis Challenge</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>üèÜ The Great Analysis Challenge</h1>
        <p class="subtitle">Multi-Language Chess Engine Comparison</p>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/evaisse/the-great-analysis-challenge">GitHub</a>
        </nav>
    </header>
    <main>
<h2>üìò <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript</a> Implementation</h2>
<div class="breadcrumb"><a href="index.html">‚Üê Back to Comparison</a></div>
<div class="file-tree">
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Dockerfile')">üìÑ Dockerfile</button>
<pre id="Dockerfile" class="file-content" style="display:none;"><code class="language-dockerfile"># Use Ubuntu base image
FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies and Node.js
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    build-essential \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install Node.js and npm
RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - \
    &amp;&amp; apt-get install -y nodejs

# Set working directory
WORKDIR /app

# Copy project files needed for dependency install and make targets
COPY package*.json ./
COPY tsconfig.json ./
COPY Makefile ./

# Install dependencies
RUN npm install

# Copy source code
COPY src/ ./src/
COPY test/ ./test/

# Build the TypeScript project
RUN npm run build

# Create a non-root user for running the engine
RUN useradd -ms /bin/bash chess

# Change ownership of the app directory to the non-root user
RUN chown -R chess:chess /app

# Switch to non-root user
USER chess

# Expose port (not needed for CLI but good practice)
EXPOSE 3000

# Default command to run the chess engine
CMD ["node", "dist/chess.js"]

# Alternative commands for different use cases:
# To build only: docker run --rm chess-engine npm run build
# To run tests: docker run --rm chess-engine npm test
# Interactive mode: docker run -it chess-engine
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Makefile')">üìÑ Makefile</button>
<pre id="Makefile" class="file-content" style="display:none;"><code class="language-makefile">.PHONY: all build test analyze clean docker-build docker-test

# Default target - build the chess engine
all: build

# Build target - compile TypeScript to JavaScript
build:
	npm install
	npm run build

# Run basic tests
test:
	npm test

# Static analysis and code quality
analyze:
	@echo "Running TypeScript static analysis..."
	npm install
	npm run lint
	npx tsc --noEmit
	npx prettier --check src/*.ts

# Clean build artifacts
clean:
	rm -rf dist/
	rm -rf node_modules/
	npm cache clean --force || true

# Docker targets
docker-build:
	docker build -t chess-typescript .

docker-test: docker-build
	@echo "Testing TypeScript implementation in Docker..."
	docker run --rm -i chess-typescript sh -c "echo -e 'new\\nmove e2e4\\nmove e7e5\\nexport\\nquit' | node dist/chess.js"

# Help target
help:
	@echo "Available targets:"
	@echo "  make         - Build the chess engine"
	@echo "  make test    - Run tests"
	@echo "  make analyze - Run static analysis"
	@echo "  make clean   - Clean build artifacts"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-test  - Test in Docker"
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('README_md')">üìÑ README.md</button>
<pre id="README_md" class="file-content" style="display:none;"><code class="language-markdown"># TypeScript Chess Engine

A complete chess engine implementation in TypeScript following the Chess Engine Specification v1.0.

## Features

- Complete chess rules implementation (castling, en passant, promotion)
- AI opponent with minimax algorithm and alpha-beta pruning
- FEN import/export support
- Performance testing with perft
- Interactive command-line interface
- All standard chess piece movements and special rules

## Local Development

### Prerequisites
- Node.js 18+ 
- npm

### Setup
```bash
npm install
npm run build
npm start
```

## Docker Usage

### Build the Docker image
```bash
docker build -t chess-engine .
```

### Run interactively
```bash
docker run -it chess-engine
```

### Using Docker Compose
```bash
# Run the chess engine
docker-compose up chess-engine

# Development mode with shell access
docker-compose run chess-dev
```

### Example Docker commands
```bash
# Quick game
echo -e "new\nmove e2e4\nmove e7e5\nai 3\nquit" | docker run -i chess-engine

# Interactive play
docker run -it chess-engine

# Build and run in one command
docker-compose up --build chess-engine
```

## Commands

- `move &lt;from&gt;&lt;to&gt;[promotion]` - Make a move (e.g., e2e4, e7e8Q)
- `undo` - Undo the last move
- `new` - Start a new game  
- `ai &lt;depth&gt;` - Let AI make a move (depth 1-5)
- `fen &lt;string&gt;` - Load position from FEN
- `export` - Export current position as FEN
- `eval` - Evaluate current position
- `perft &lt;depth&gt;` - Run performance test
- `help` - Show available commands
- `quit` - Exit the program

## Architecture

- `src/types.ts` - Type definitions and constants
- `src/board.ts` - Board representation and game state
- `src/moveGenerator.ts` - Move generation and validation  
- `src/fen.ts` - FEN parsing and serialization
- `src/ai.ts` - AI engine with minimax/alpha-beta
- `src/perft.ts` - Performance testing utilities
- `src/chess.ts` - Main engine and command interface

## Testing

The engine includes perft testing for move generation verification:
```bash
# In the chess engine
perft 4
```

Expected result: 197281 nodes for perft(4) from starting position.</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('chess_meta')">üìÑ chess.meta</button>
<pre id="chess_meta" class="file-content" style="display:none;"><code class="language-typescript">{
  "language": "typescript",
  "version": "5.0",
  "author": "TypeScript Implementation",
  "build": "npm install &amp;&amp; npm run build",
  "run": "node dist/chess.js",
  "analyze": "npm install &amp;&amp; npm run lint &amp;&amp; npx tsc --noEmit &amp;&amp; npx prettier --check src/*.ts",
  "test": "npm install &amp;&amp; npm test",
  "features": ["perft", "fen", "ai", "castling", "en_passant", "promotion"],
  "max_ai_depth": 5,
  "estimated_perft4_ms": 800
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('docker-compose_yml')">üìÑ docker-compose.yml</button>
<pre id="docker-compose_yml" class="file-content" style="display:none;"><code class="language-yaml">version: '3.8'

services:
  chess-engine:
    build: .
    image: chess-engine:latest
    container_name: typescript-chess
    stdin_open: true
    tty: true
    volumes:
      - ./src:/app/src:ro
    environment:
      - NODE_ENV=production
    # For interactive play
    command: ["node", "dist/chess.js"]
    
  # Alternative service for development
  chess-dev:
    build: .
    image: chess-engine:latest
    container_name: typescript-chess-dev
    stdin_open: true
    tty: true
    volumes:
      - .:/app
    working_dir: /app
    command: ["sh"]
    environment:
      - NODE_ENV=development</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('package-lock_json')">üìÑ package-lock.json</button>
<pre id="package-lock_json" class="file-content" style="display:none;"><code class="language-json">{
  "name": "typescript",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "typescript",
      "version": "1.0.0",
      "license": "ISC",
      "devDependencies": {
        "@types/node": "^24.3.1",
        "prettier": "^3.0.0",
        "typescript": "^5.9.2"
      }
    },
    "node_modules/@types/node": {
      "version": "24.3.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.3.1.tgz",
      "integrity": "sha512-3vXmQDXy+woz+gnrTvuvNrPzekOi+Ds0ReMxw0LzBiK3a+1k0kQn9f2NWk+lgD4rJehFUmYy2gMhJ2ZI+7YP9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.10.0"
      }
    },
    "node_modules/prettier": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.6.2.tgz",
      "integrity": "sha512-I7AIg5boAr5R0FFtJ6rCfD+LFsWHp81dolrFD8S79U9tb8Az2nGrJncnMSnys+bpQJfRUzqs9hnA81OAA3hCuQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "prettier": "bin/prettier.cjs"
      },
      "engines": {
        "node": "&gt;=14"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": "&gt;=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "7.10.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.10.0.tgz",
      "integrity": "sha512-t5Fy/nfn+14LuOc2KNYg75vZqClpAiqscVvMygNnlsHBFpSXdJaYtXMcdNLpl/Qvc3P2cB3s6lOV51nqsFq4ag==",
      "dev": true,
      "license": "MIT"
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('package_json')">üìÑ package.json</button>
<pre id="package_json" class="file-content" style="display:none;"><code class="language-json">{
  "name": "typescript",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/chess.js",
    "dev": "tsc &amp;&amp; node dist/chess.js",
    "chess": "npm run build &amp;&amp; npm start",
    "test": "npm run build &amp;&amp; node test/basic.test.js",
    "lint": "echo \"No linter configured yet\" &amp;&amp; exit 0"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@types/node": "^24.3.1",
    "typescript": "^5.9.2",
    "prettier": "^3.0.0"
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_ai_ts')">üìÑ src/ai.ts</button>
<pre id="src_ai_ts" class="file-content" style="display:none;"><code class="language-typescript">import { Board } from "./board";
import { MoveGenerator } from "./moveGenerator";
import { Move, Color, Square, PIECE_VALUES } from "./types";

export class AI {
  private board: Board;
  private moveGenerator: MoveGenerator;
  private nodesEvaluated: number = 0;

  constructor(board: Board, moveGenerator: MoveGenerator) {
    this.board = board;
    this.moveGenerator = moveGenerator;
  }

  public findBestMove(depth: number): {
    move: Move | null;
    eval: number;
    nodes: number;
    time: number;
  } {
    const startTime = Date.now();
    this.nodesEvaluated = 0;

    const color = this.board.getTurn();
    const moves = this.moveGenerator.getLegalMoves(color);

    if (moves.length === 0) {
      return { move: null, eval: 0, nodes: 0, time: 0 };
    }

    let bestMove = moves[0];
    let bestEval = color === "white" ? -Infinity : Infinity;
    const alpha = -Infinity;
    const beta = Infinity;

    for (const move of moves) {
      const state = this.board.getState();
      this.board.makeMove(move);

      const evaluation = this.minimax(
        depth - 1,
        alpha,
        beta,
        color === "black",
      );

      this.board.setState(state);

      if (color === "white" &amp;&amp; evaluation &gt; bestEval) {
        bestEval = evaluation;
        bestMove = move;
      } else if (color === "black" &amp;&amp; evaluation &lt; bestEval) {
        bestEval = evaluation;
        bestMove = move;
      }
    }

    const endTime = Date.now();
    return {
      move: bestMove,
      eval: bestEval,
      nodes: this.nodesEvaluated,
      time: endTime - startTime,
    };
  }

  private minimax(
    depth: number,
    alpha: number,
    beta: number,
    maximizing: boolean,
  ): number {
    this.nodesEvaluated++;

    if (depth === 0) {
      return this.evaluate();
    }

    const color = this.board.getTurn();
    const moves = this.moveGenerator.getLegalMoves(color);

    if (moves.length === 0) {
      if (this.moveGenerator.isInCheck(color)) {
        return maximizing ? -100000 : 100000;
      }
      return 0;
    }

    if (maximizing) {
      let maxEval = -Infinity;

      for (const move of moves) {
        const state = this.board.getState();
        this.board.makeMove(move);

        const evaluation = this.minimax(depth - 1, alpha, beta, false);

        this.board.setState(state);

        maxEval = Math.max(maxEval, evaluation);
        alpha = Math.max(alpha, evaluation);

        if (beta &lt;= alpha) {
          break;
        }
      }

      return maxEval;
    } else {
      let minEval = Infinity;

      for (const move of moves) {
        const state = this.board.getState();
        this.board.makeMove(move);

        const evaluation = this.minimax(depth - 1, alpha, beta, true);

        this.board.setState(state);

        minEval = Math.min(minEval, evaluation);
        beta = Math.min(beta, evaluation);

        if (beta &lt;= alpha) {
          break;
        }
      }

      return minEval;
    }
  }

  private evaluate(): number {
    let score = 0;

    for (let square = 0; square &lt; 64; square++) {
      const piece = this.board.getPiece(square);
      if (piece) {
        const value = PIECE_VALUES[piece.type];
        const positionBonus = this.getPositionBonus(
          square,
          piece.type,
          piece.color,
        );
        const totalValue = value + positionBonus;

        score += piece.color === "white" ? totalValue : -totalValue;
      }
    }

    return score;
  }

  private getPositionBonus(
    square: Square,
    pieceType: string,
    color: Color,
  ): number {
    const file = square % 8;
    const rank = Math.floor(square / 8);
    let bonus = 0;

    const centerSquares = [27, 28, 35, 36];
    if (centerSquares.includes(square)) {
      bonus += 10;
    }

    if (pieceType === "P") {
      const advancement = color === "white" ? rank : 7 - rank;
      bonus += advancement * 5;
    }

    if (pieceType === "K") {
      const isEndgame = this.isEndgame();
      if (!isEndgame) {
        const kingSafetyRow = color === "white" ? 0 : 7;
        if (rank === kingSafetyRow &amp;&amp; (file &lt;= 2 || file &gt;= 5)) {
          bonus += 20;
        } else {
          bonus -= 20;
        }
      }
    }

    return bonus;
  }

  private isEndgame(): number {
    let pieceCount = 0;
    let queenCount = 0;

    for (let square = 0; square &lt; 64; square++) {
      const piece = this.board.getPiece(square);
      if (piece) {
        if (piece.type !== "K" &amp;&amp; piece.type !== "P") {
          pieceCount++;
          if (piece.type === "Q") {
            queenCount++;
          }
        }
      }
    }

    return pieceCount &lt;= 4 || (pieceCount &lt;= 6 &amp;&amp; queenCount === 0) ? 1 : 0;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_board_ts')">üìÑ src/board.ts</button>
<pre id="src_board_ts" class="file-content" style="display:none;"><code class="language-typescript">import {
  Piece,
  Color,
  Square,
  Move,
  CastlingRights,
  GameState,
  FILES,
  RANKS,
} from "./types";

export class Board {
  private state: GameState;

  constructor() {
    this.state = this.createInitialState();
  }

  private createInitialState(): GameState {
    const board: (Piece | null)[] = new Array(64).fill(null);

    const pieces: [Square, Piece][] = [
      [0, { type: "R", color: "white" }],
      [1, { type: "N", color: "white" }],
      [2, { type: "B", color: "white" }],
      [3, { type: "Q", color: "white" }],
      [4, { type: "K", color: "white" }],
      [5, { type: "B", color: "white" }],
      [6, { type: "N", color: "white" }],
      [7, { type: "R", color: "white" }],

      [56, { type: "R", color: "black" }],
      [57, { type: "N", color: "black" }],
      [58, { type: "B", color: "black" }],
      [59, { type: "Q", color: "black" }],
      [60, { type: "K", color: "black" }],
      [61, { type: "B", color: "black" }],
      [62, { type: "N", color: "black" }],
      [63, { type: "R", color: "black" }],
    ];

    for (let i = 8; i &lt; 16; i++) {
      pieces.push([i, { type: "P", color: "white" }]);
    }
    for (let i = 48; i &lt; 56; i++) {
      pieces.push([i, { type: "P", color: "black" }]);
    }

    for (const [square, piece] of pieces) {
      board[square] = piece;
    }

    return {
      board,
      turn: "white",
      castlingRights: {
        whiteKingside: true,
        whiteQueenside: true,
        blackKingside: true,
        blackQueenside: true,
      },
      enPassantTarget: null,
      halfmoveClock: 0,
      fullmoveNumber: 1,
      moveHistory: [],
    };
  }

  public reset(): void {
    this.state = this.createInitialState();
  }

  public getState(): GameState {
    return { ...this.state };
  }

  public setState(state: GameState): void {
    this.state = { ...state };
  }

  public getPiece(square: Square): Piece | null {
    return this.state.board[square];
  }

  public setPiece(square: Square, piece: Piece | null): void {
    this.state.board[square] = piece;
  }

  public getTurn(): Color {
    return this.state.turn;
  }

  public setTurn(color: Color): void {
    this.state.turn = color;
  }

  public getCastlingRights(): CastlingRights {
    return { ...this.state.castlingRights };
  }

  public setCastlingRights(rights: CastlingRights): void {
    this.state.castlingRights = { ...rights };
  }

  public getEnPassantTarget(): Square | null {
    return this.state.enPassantTarget;
  }

  public setEnPassantTarget(square: Square | null): void {
    this.state.enPassantTarget = square;
  }

  public squareToAlgebraic(square: Square): string {
    const file = square % 8;
    const rank = Math.floor(square / 8);
    return FILES[file] + RANKS[rank];
  }

  public algebraicToSquare(algebraic: string): Square {
    const file = FILES.indexOf(algebraic[0]);
    const rank = RANKS.indexOf(algebraic[1]);
    if (file === -1 || rank === -1) {
      throw new Error(`Invalid algebraic notation: ${algebraic}`);
    }
    return rank * 8 + file;
  }

  public makeMove(move: Move): void {
    const piece = this.getPiece(move.from);
    if (!piece) return;

    this.setPiece(move.to, piece);
    this.setPiece(move.from, null);

    if (move.castling) {
      const rank = piece.color === "white" ? 0 : 7;
      if (move.castling === "K" || move.castling === "k") {
        const rookFrom = rank * 8 + 7;
        const rookTo = rank * 8 + 5;
        const rook = this.getPiece(rookFrom);
        if (rook) {
          this.setPiece(rookTo, rook);
          this.setPiece(rookFrom, null);
        }
      } else {
        const rookFrom = rank * 8;
        const rookTo = rank * 8 + 3;
        const rook = this.getPiece(rookFrom);
        if (rook) {
          this.setPiece(rookTo, rook);
          this.setPiece(rookFrom, null);
        }
      }
    }

    if (move.enPassant) {
      const capturedPawnSquare = move.to + (piece.color === "white" ? -8 : 8);
      this.setPiece(capturedPawnSquare, null);
    }

    if (move.promotion) {
      this.setPiece(move.to, { type: move.promotion, color: piece.color });
    }

    const rights = this.getCastlingRights();
    if (piece.type === "K") {
      if (piece.color === "white") {
        rights.whiteKingside = false;
        rights.whiteQueenside = false;
      } else {
        rights.blackKingside = false;
        rights.blackQueenside = false;
      }
    } else if (piece.type === "R") {
      if (piece.color === "white") {
        if (move.from === 0) rights.whiteQueenside = false;
        if (move.from === 7) rights.whiteKingside = false;
      } else {
        if (move.from === 56) rights.blackQueenside = false;
        if (move.from === 63) rights.blackKingside = false;
      }
    }
    this.setCastlingRights(rights);

    if (piece.type === "P" &amp;&amp; Math.abs(move.to - move.from) === 16) {
      const enPassantSquare = (move.from + move.to) / 2;
      this.setEnPassantTarget(enPassantSquare);
    } else {
      this.setEnPassantTarget(null);
    }

    if (piece.type === "P" || move.captured) {
      this.state.halfmoveClock = 0;
    } else {
      this.state.halfmoveClock++;
    }

    if (piece.color === "black") {
      this.state.fullmoveNumber++;
    }

    this.setTurn(piece.color === "white" ? "black" : "white");
    this.state.moveHistory.push(move);
  }

  public undoMove(): Move | null {
    const move = this.state.moveHistory.pop();
    if (!move) return null;

    const piece = this.getPiece(move.to);
    if (!piece) return null;

    if (move.promotion) {
      this.setPiece(move.from, { type: "P", color: piece.color });
    } else {
      this.setPiece(move.from, piece);
    }

    if (move.captured) {
      const capturedColor = piece.color === "white" ? "black" : "white";
      this.setPiece(move.to, { type: move.captured, color: capturedColor });
    } else {
      this.setPiece(move.to, null);
    }

    if (move.castling) {
      const rank = piece.color === "white" ? 0 : 7;
      if (move.castling === "K" || move.castling === "k") {
        const rookFrom = rank * 8 + 5;
        const rookTo = rank * 8 + 7;
        const rook = this.getPiece(rookFrom);
        if (rook) {
          this.setPiece(rookTo, rook);
          this.setPiece(rookFrom, null);
        }
      } else {
        const rookFrom = rank * 8 + 3;
        const rookTo = rank * 8;
        const rook = this.getPiece(rookFrom);
        if (rook) {
          this.setPiece(rookTo, rook);
          this.setPiece(rookFrom, null);
        }
      }
    }

    if (move.enPassant) {
      const capturedPawnSquare = move.to + (piece.color === "white" ? -8 : 8);
      const capturedColor = piece.color === "white" ? "black" : "white";
      this.setPiece(capturedPawnSquare, { type: "P", color: capturedColor });
    }

    this.setTurn(piece.color);

    return move;
  }

  public display(): string {
    let output = "  a b c d e f g h\n";

    for (let rank = 7; rank &gt;= 0; rank--) {
      output += `${rank + 1} `;
      for (let file = 0; file &lt; 8; file++) {
        const square = rank * 8 + file;
        const piece = this.getPiece(square);
        if (piece) {
          const char =
            piece.color === "white" ? piece.type : piece.type.toLowerCase();
          output += `${char} `;
        } else {
          output += ". ";
        }
      }
      output += `${rank + 1}\n`;
    }

    output += "  a b c d e f g h\n\n";
    output += `${this.state.turn === "white" ? "White" : "Black"} to move`;

    return output;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_chess_ts')">üìÑ src/chess.ts</button>
<pre id="src_chess_ts" class="file-content" style="display:none;"><code class="language-typescript">import * as readline from "readline";
import { Board } from "./board";
import { MoveGenerator } from "./moveGenerator";
import { FenParser } from "./fen";
import { AI } from "./ai";
import { Perft } from "./perft";
import { Move, PieceType } from "./types";

export class ChessEngine {
  private board: Board;
  private moveGenerator: MoveGenerator;
  private fenParser: FenParser;
  private ai: AI;
  private perft: Perft;
  private rl: readline.Interface;

  constructor() {
    this.board = new Board();
    this.moveGenerator = new MoveGenerator(this.board);
    this.fenParser = new FenParser(this.board);
    this.ai = new AI(this.board, this.moveGenerator);
    this.perft = new Perft(this.board, this.moveGenerator);

    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false,
    });
  }

  public start(): void {
    console.log(this.board.display());

    this.rl.on("line", (input: string) =&gt; {
      const trimmed = input.trim();
      if (trimmed) {
        this.processCommand(trimmed);
      }
    });
  }

  private processCommand(command: string): void {
    const parts = command.split(" ");
    const cmd = parts[0].toLowerCase();

    try {
      switch (cmd) {
        case "move":
          this.handleMove(parts[1]);
          break;
        case "undo":
          this.handleUndo();
          break;
        case "new":
          this.handleNew();
          break;
        case "ai":
          this.handleAI(parts[1]);
          break;
        case "fen":
          this.handleFen(parts.slice(1).join(" "));
          break;
        case "export":
          this.handleExport();
          break;
        case "eval":
          this.handleEval();
          break;
        case "perft":
          this.handlePerft(parts[1]);
          break;
        case "help":
          this.handleHelp();
          break;
        case "quit":
          process.exit(0);
          break;
        default:
          console.log("ERROR: Invalid command");
          break;
      }
    } catch (error: any) {
      console.log(error.message || "ERROR: Invalid command");
    }
  }

  private handleMove(moveStr: string): void {
    if (!moveStr || moveStr.length &lt; 4) {
      console.log("ERROR: Invalid move format");
      return;
    }

    const from = moveStr.substring(0, 2);
    const to = moveStr.substring(2, 4);
    const promotion = moveStr.substring(4, 5).toUpperCase() as PieceType;

    try {
      const fromSquare = this.board.algebraicToSquare(from);
      const toSquare = this.board.algebraicToSquare(to);

      const piece = this.board.getPiece(fromSquare);
      if (!piece) {
        console.log("ERROR: No piece at source square");
        return;
      }

      if (piece.color !== this.board.getTurn()) {
        console.log("ERROR: Wrong color piece");
        return;
      }

      const legalMoves = this.moveGenerator.getLegalMoves(this.board.getTurn());
      const move = legalMoves.find(
        (m) =&gt;
          m.from === fromSquare &amp;&amp;
          m.to === toSquare &amp;&amp;
          (!m.promotion ||
            m.promotion === promotion ||
            (!promotion &amp;&amp; m.promotion === "Q")),
      );

      if (!move) {
        const inCheck = this.moveGenerator.isInCheck(this.board.getTurn());
        if (inCheck) {
          console.log("ERROR: King would be in check");
        } else {
          console.log("ERROR: Illegal move");
        }
        return;
      }

      if (move.promotion &amp;&amp; !promotion) {
        move.promotion = "Q";
      } else if (move.promotion &amp;&amp; promotion) {
        move.promotion = promotion;
      }

      this.board.makeMove(move);
      console.log(`OK: ${moveStr}`);
      console.log(this.board.display());

      this.checkGameEnd();
    } catch (error) {
      console.log("ERROR: Invalid move format");
    }
  }

  private handleUndo(): void {
    const move = this.board.undoMove();
    if (move) {
      console.log("Move undone");
      console.log(this.board.display());
    } else {
      console.log("ERROR: No moves to undo");
    }
  }

  private handleNew(): void {
    this.board.reset();
    console.log("New game started");
    console.log(this.board.display());
  }

  private handleAI(depthStr: string): void {
    const depth = parseInt(depthStr);
    if (isNaN(depth) || depth &lt; 1 || depth &gt; 5) {
      console.log("ERROR: AI depth must be 1-5");
      return;
    }

    const result = this.ai.findBestMove(depth);
    if (!result.move) {
      console.log("ERROR: No legal moves available");
      return;
    }

    const moveStr =
      this.board.squareToAlgebraic(result.move.from) +
      this.board.squareToAlgebraic(result.move.to) +
      (result.move.promotion || "");

    this.board.makeMove(result.move);
    console.log(
      `AI: ${moveStr} (depth=${depth}, eval=${result.eval}, time=${result.time}ms)`,
    );
    console.log(this.board.display());

    this.checkGameEnd();
  }

  private handleFen(fenString: string): void {
    try {
      this.fenParser.parseFen(fenString);
      console.log("Position loaded from FEN");
      console.log(this.board.display());
    } catch (error) {
      console.log("ERROR: Invalid FEN string");
    }
  }

  private handleExport(): void {
    const fen = this.fenParser.exportFen();
    console.log(`FEN: ${fen}`);
  }

  private handleEval(): void {
    const evaluation = this.evaluatePosition();
    console.log(`Position evaluation: ${evaluation}`);
  }

  private evaluatePosition(): number {
    let score = 0;
    for (let square = 0; square &lt; 64; square++) {
      const piece = this.board.getPiece(square);
      if (piece) {
        const value = {
          P: 100,
          N: 320,
          B: 330,
          R: 500,
          Q: 900,
          K: 20000,
        }[piece.type];
        score += piece.color === "white" ? value : -value;
      }
    }
    return score;
  }

  private handlePerft(depthStr: string): void {
    const depth = parseInt(depthStr);
    if (isNaN(depth) || depth &lt; 1) {
      console.log("ERROR: Invalid perft depth");
      return;
    }

    const startTime = Date.now();
    const nodes = this.perft.perft(depth);
    const endTime = Date.now();

    console.log(`Perft(${depth}): ${nodes} nodes (${endTime - startTime}ms)`);
  }

  private handleHelp(): void {
    console.log("Available commands:");
    console.log(
      "  move &lt;from&gt;&lt;to&gt;[promotion] - Make a move (e.g., e2e4, e7e8Q)",
    );
    console.log("  undo - Undo the last move");
    console.log("  new - Start a new game");
    console.log("  ai &lt;depth&gt; - Let AI make a move (depth 1-5)");
    console.log("  fen &lt;string&gt; - Load position from FEN");
    console.log("  export - Export current position as FEN");
    console.log("  eval - Evaluate current position");
    console.log("  perft &lt;depth&gt; - Run performance test");
    console.log("  help - Show this help message");
    console.log("  quit - Exit the program");
  }

  private checkGameEnd(): void {
    const color = this.board.getTurn();
    const legalMoves = this.moveGenerator.getLegalMoves(color);

    if (legalMoves.length === 0) {
      if (this.moveGenerator.isInCheck(color)) {
        const winner = color === "white" ? "Black" : "White";
        console.log(`CHECKMATE: ${winner} wins`);
      } else {
        console.log("STALEMATE: Draw");
      }
    }
  }
}

const engine = new ChessEngine();
engine.start();
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_fen_ts')">üìÑ src/fen.ts</button>
<pre id="src_fen_ts" class="file-content" style="display:none;"><code class="language-typescript">import { Board } from "./board";
import { Piece, Color, CastlingRights, Square } from "./types";

export class FenParser {
  private board: Board;

  constructor(board: Board) {
    this.board = board;
  }

  public parseFen(fen: string): void {
    const parts = fen.split(" ");
    if (parts.length &lt; 4) {
      throw new Error("ERROR: Invalid FEN string");
    }

    const [pieces, turn, castling, enPassant, halfmove = "0", fullmove = "1"] =
      parts;

    for (let i = 0; i &lt; 64; i++) {
      this.board.setPiece(i, null);
    }

    let square = 56;
    for (const char of pieces) {
      if (char === "/") {
        square -= 16;
      } else if ("12345678".includes(char)) {
        square += parseInt(char);
      } else {
        const piece = this.charToPiece(char);
        if (piece) {
          this.board.setPiece(square, piece);
          square++;
        }
      }
    }

    this.board.setTurn(turn === "w" ? "white" : "black");

    const rights: CastlingRights = {
      whiteKingside: castling.includes("K"),
      whiteQueenside: castling.includes("Q"),
      blackKingside: castling.includes("k"),
      blackQueenside: castling.includes("q"),
    };
    this.board.setCastlingRights(rights);

    if (enPassant !== "-") {
      try {
        const epSquare = this.board.algebraicToSquare(enPassant);
        this.board.setEnPassantTarget(epSquare);
      } catch {
        this.board.setEnPassantTarget(null);
      }
    } else {
      this.board.setEnPassantTarget(null);
    }

    const state = this.board.getState();
    state.halfmoveClock = parseInt(halfmove) || 0;
    state.fullmoveNumber = parseInt(fullmove) || 1;
    this.board.setState(state);
  }

  public exportFen(): string {
    const pieces = this.getPiecesString();
    const turn = this.board.getTurn() === "white" ? "w" : "b";
    const castling = this.getCastlingString();
    const enPassant = this.getEnPassantString();
    const state = this.board.getState();

    return `${pieces} ${turn} ${castling} ${enPassant} ${state.halfmoveClock} ${state.fullmoveNumber}`;
  }

  private getPiecesString(): string {
    let result = "";

    for (let rank = 7; rank &gt;= 0; rank--) {
      let emptyCount = 0;

      for (let file = 0; file &lt; 8; file++) {
        const square = rank * 8 + file;
        const piece = this.board.getPiece(square);

        if (piece) {
          if (emptyCount &gt; 0) {
            result += emptyCount.toString();
            emptyCount = 0;
          }
          result += this.pieceToChar(piece);
        } else {
          emptyCount++;
        }
      }

      if (emptyCount &gt; 0) {
        result += emptyCount.toString();
      }

      if (rank &gt; 0) {
        result += "/";
      }
    }

    return result;
  }

  private getCastlingString(): string {
    const rights = this.board.getCastlingRights();
    let result = "";

    if (rights.whiteKingside) result += "K";
    if (rights.whiteQueenside) result += "Q";
    if (rights.blackKingside) result += "k";
    if (rights.blackQueenside) result += "q";

    return result || "-";
  }

  private getEnPassantString(): string {
    const target = this.board.getEnPassantTarget();
    if (target === null) {
      return "-";
    }
    return this.board.squareToAlgebraic(target);
  }

  private charToPiece(char: string): Piece | null {
    const isWhite = char === char.toUpperCase();
    const type = char.toUpperCase();

    switch (type) {
      case "P":
        return { type: "P", color: isWhite ? "white" : "black" };
      case "N":
        return { type: "N", color: isWhite ? "white" : "black" };
      case "B":
        return { type: "B", color: isWhite ? "white" : "black" };
      case "R":
        return { type: "R", color: isWhite ? "white" : "black" };
      case "Q":
        return { type: "Q", color: isWhite ? "white" : "black" };
      case "K":
        return { type: "K", color: isWhite ? "white" : "black" };
      default:
        return null;
    }
  }

  private pieceToChar(piece: Piece): string {
    const char = piece.type;
    return piece.color === "white" ? char : char.toLowerCase();
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_moveGenerator_ts')">üìÑ src/moveGenerator.ts</button>
<pre id="src_moveGenerator_ts" class="file-content" style="display:none;"><code class="language-typescript">import { Board } from "./board";
import { Move, Piece, Color, Square, PieceType } from "./types";

export class MoveGenerator {
  private board: Board;

  constructor(board: Board) {
    this.board = board;
  }

  public generateAllMoves(color: Color): Move[] {
    const moves: Move[] = [];

    for (let square = 0; square &lt; 64; square++) {
      const piece = this.board.getPiece(square);
      if (piece &amp;&amp; piece.color === color) {
        moves.push(...this.generatePieceMoves(square, piece));
      }
    }

    return moves;
  }

  public generatePieceMoves(from: Square, piece: Piece): Move[] {
    switch (piece.type) {
      case "P":
        return this.generatePawnMoves(from, piece);
      case "N":
        return this.generateKnightMoves(from, piece);
      case "B":
        return this.generateBishopMoves(from, piece);
      case "R":
        return this.generateRookMoves(from, piece);
      case "Q":
        return this.generateQueenMoves(from, piece);
      case "K":
        return this.generateKingMoves(from, piece);
      default:
        return [];
    }
  }

  private generatePawnMoves(from: Square, piece: Piece): Move[] {
    const moves: Move[] = [];
    const direction = piece.color === "white" ? 8 : -8;
    const startRank = piece.color === "white" ? 1 : 6;
    const promotionRank = piece.color === "white" ? 7 : 0;
    const rank = Math.floor(from / 8);
    const file = from % 8;

    const oneSquareForward = from + direction;
    if (
      this.isValidSquare(oneSquareForward) &amp;&amp;
      !this.board.getPiece(oneSquareForward)
    ) {
      if (Math.floor(oneSquareForward / 8) === promotionRank) {
        (["Q", "R", "B", "N"] as PieceType[]).forEach((promo) =&gt; {
          moves.push({
            from,
            to: oneSquareForward,
            piece: "P",
            promotion: promo,
          });
        });
      } else {
        moves.push({ from, to: oneSquareForward, piece: "P" });
      }

      if (rank === startRank) {
        const twoSquaresForward = from + 2 * direction;
        if (!this.board.getPiece(twoSquaresForward)) {
          moves.push({ from, to: twoSquaresForward, piece: "P" });
        }
      }
    }

    const captureOffsets = [direction - 1, direction + 1];
    captureOffsets.forEach((offset) =&gt; {
      const to = from + offset;
      const toFile = to % 8;

      if (Math.abs(toFile - file) === 1 &amp;&amp; this.isValidSquare(to)) {
        const target = this.board.getPiece(to);
        if (target &amp;&amp; target.color !== piece.color) {
          if (Math.floor(to / 8) === promotionRank) {
            (["Q", "R", "B", "N"] as PieceType[]).forEach((promo) =&gt; {
              moves.push({
                from,
                to,
                piece: "P",
                captured: target.type,
                promotion: promo,
              });
            });
          } else {
            moves.push({ from, to, piece: "P", captured: target.type });
          }
        }
      }
    });

    const enPassantTarget = this.board.getEnPassantTarget();
    if (enPassantTarget !== null) {
      const epRank = Math.floor(enPassantTarget / 8);
      const expectedPawnRank = piece.color === "white" ? 4 : 3;

      if (rank === expectedPawnRank) {
        [-1, 1].forEach((offset) =&gt; {
          const adjacentSquare = from + offset;
          const adjFile = adjacentSquare % 8;

          if (Math.abs(adjFile - file) === 1) {
            const targetPawnSquare = adjacentSquare;
            const targetPawn = this.board.getPiece(targetPawnSquare);

            if (
              targetPawn &amp;&amp;
              targetPawn.type === "P" &amp;&amp;
              targetPawn.color !== piece.color
            ) {
              const captureSquare = enPassantTarget;
              if (captureSquare === targetPawnSquare + direction) {
                moves.push({
                  from,
                  to: captureSquare,
                  piece: "P",
                  enPassant: true,
                  captured: "P",
                });
              }
            }
          }
        });
      }
    }

    return moves;
  }

  private generateKnightMoves(from: Square, piece: Piece): Move[] {
    const moves: Move[] = [];
    const offsets = [-17, -15, -10, -6, 6, 10, 15, 17];
    const file = from % 8;

    offsets.forEach((offset) =&gt; {
      const to = from + offset;
      const toFile = to % 8;

      if (this.isValidSquare(to) &amp;&amp; Math.abs(toFile - file) &lt;= 2) {
        const target = this.board.getPiece(to);
        if (!target || target.color !== piece.color) {
          moves.push({ from, to, piece: "N", captured: target?.type });
        }
      }
    });

    return moves;
  }

  private generateBishopMoves(from: Square, piece: Piece): Move[] {
    return this.generateSlidingMoves(from, piece, [-9, -7, 7, 9], true);
  }

  private generateRookMoves(from: Square, piece: Piece): Move[] {
    return this.generateSlidingMoves(from, piece, [-8, -1, 1, 8], false);
  }

  private generateQueenMoves(from: Square, piece: Piece): Move[] {
    return this.generateSlidingMoves(
      from,
      piece,
      [-9, -8, -7, -1, 1, 7, 8, 9],
      null,
    );
  }

  private generateKingMoves(from: Square, piece: Piece): Move[] {
    const moves: Move[] = [];
    const offsets = [-9, -8, -7, -1, 1, 7, 8, 9];
    const file = from % 8;

    offsets.forEach((offset) =&gt; {
      const to = from + offset;
      const toFile = to % 8;

      if (this.isValidSquare(to) &amp;&amp; Math.abs(toFile - file) &lt;= 1) {
        const target = this.board.getPiece(to);
        if (!target || target.color !== piece.color) {
          moves.push({ from, to, piece: "K", captured: target?.type });
        }
      }
    });

    const rights = this.board.getCastlingRights();
    if (piece.color === "white" &amp;&amp; from === 4) {
      if (
        rights.whiteKingside &amp;&amp;
        !this.board.getPiece(5) &amp;&amp;
        !this.board.getPiece(6) &amp;&amp;
        this.board.getPiece(7)?.type === "R"
      ) {
        if (
          !this.isSquareAttacked(4, "black") &amp;&amp;
          !this.isSquareAttacked(5, "black") &amp;&amp;
          !this.isSquareAttacked(6, "black")
        ) {
          moves.push({ from: 4, to: 6, piece: "K", castling: "K" });
        }
      }
      if (
        rights.whiteQueenside &amp;&amp;
        !this.board.getPiece(3) &amp;&amp;
        !this.board.getPiece(2) &amp;&amp;
        !this.board.getPiece(1) &amp;&amp;
        this.board.getPiece(0)?.type === "R"
      ) {
        if (
          !this.isSquareAttacked(4, "black") &amp;&amp;
          !this.isSquareAttacked(3, "black") &amp;&amp;
          !this.isSquareAttacked(2, "black")
        ) {
          moves.push({ from: 4, to: 2, piece: "K", castling: "Q" });
        }
      }
    } else if (piece.color === "black" &amp;&amp; from === 60) {
      if (
        rights.blackKingside &amp;&amp;
        !this.board.getPiece(61) &amp;&amp;
        !this.board.getPiece(62) &amp;&amp;
        this.board.getPiece(63)?.type === "R"
      ) {
        if (
          !this.isSquareAttacked(60, "white") &amp;&amp;
          !this.isSquareAttacked(61, "white") &amp;&amp;
          !this.isSquareAttacked(62, "white")
        ) {
          moves.push({ from: 60, to: 62, piece: "K", castling: "k" });
        }
      }
      if (
        rights.blackQueenside &amp;&amp;
        !this.board.getPiece(59) &amp;&amp;
        !this.board.getPiece(58) &amp;&amp;
        !this.board.getPiece(57) &amp;&amp;
        this.board.getPiece(56)?.type === "R"
      ) {
        if (
          !this.isSquareAttacked(60, "white") &amp;&amp;
          !this.isSquareAttacked(59, "white") &amp;&amp;
          !this.isSquareAttacked(58, "white")
        ) {
          moves.push({ from: 60, to: 58, piece: "K", castling: "q" });
        }
      }
    }

    return moves;
  }

  private generateSlidingMoves(
    from: Square,
    piece: Piece,
    directions: number[],
    isDiagonal: boolean | null,
  ): Move[] {
    const moves: Move[] = [];
    const file = from % 8;

    directions.forEach((direction) =&gt; {
      let to = from + direction;
      let prevFile = file;

      while (this.isValidSquare(to)) {
        const toFile = to % 8;

        if (isDiagonal === true &amp;&amp; Math.abs(toFile - prevFile) !== 1) break;
        if ((isDiagonal === false &amp;&amp; direction === -1) || direction === 1) {
          if (Math.abs(toFile - prevFile) !== 1) break;
        }

        const target = this.board.getPiece(to);
        if (!target) {
          moves.push({ from, to, piece: piece.type, captured: undefined });
        } else if (target.color !== piece.color) {
          moves.push({ from, to, piece: piece.type, captured: target.type });
          break;
        } else {
          break;
        }

        prevFile = toFile;
        to += direction;
      }
    });

    return moves;
  }

  public isSquareAttacked(square: Square, byColor: Color): boolean {
    for (let from = 0; from &lt; 64; from++) {
      const piece = this.board.getPiece(from);
      if (piece &amp;&amp; piece.color === byColor) {
        const moves = this.generatePieceMoves(from, piece);
        if (moves.some((move) =&gt; move.to === square)) {
          return true;
        }
      }
    }
    return false;
  }

  public isInCheck(color: Color): boolean {
    for (let square = 0; square &lt; 64; square++) {
      const piece = this.board.getPiece(square);
      if (piece &amp;&amp; piece.type === "K" &amp;&amp; piece.color === color) {
        return this.isSquareAttacked(
          square,
          color === "white" ? "black" : "white",
        );
      }
    }
    return false;
  }

  public getLegalMoves(color: Color): Move[] {
    const moves = this.generateAllMoves(color);
    const legalMoves: Move[] = [];

    for (const move of moves) {
      const state = this.board.getState();
      this.board.makeMove(move);

      if (!this.isInCheck(color)) {
        legalMoves.push(move);
      }

      this.board.setState(state);
    }

    return legalMoves;
  }

  public isCheckmate(color: Color): boolean {
    return this.isInCheck(color) &amp;&amp; this.getLegalMoves(color).length === 0;
  }

  public isStalemate(color: Color): boolean {
    return !this.isInCheck(color) &amp;&amp; this.getLegalMoves(color).length === 0;
  }

  private isValidSquare(square: Square): boolean {
    return square &gt;= 0 &amp;&amp; square &lt; 64;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_perft_ts')">üìÑ src/perft.ts</button>
<pre id="src_perft_ts" class="file-content" style="display:none;"><code class="language-typescript">import { Board } from "./board";
import { MoveGenerator } from "./moveGenerator";
import { Color } from "./types";

export class Perft {
  private board: Board;
  private moveGenerator: MoveGenerator;

  constructor(board: Board, moveGenerator: MoveGenerator) {
    this.board = board;
    this.moveGenerator = moveGenerator;
  }

  public perft(depth: number): number {
    if (depth === 0) {
      return 1;
    }

    const color = this.board.getTurn();
    const moves = this.moveGenerator.getLegalMoves(color);
    let nodes = 0;

    for (const move of moves) {
      const state = this.board.getState();
      this.board.makeMove(move);
      nodes += this.perft(depth - 1);
      this.board.setState(state);
    }

    return nodes;
  }

  public perftDivide(depth: number): Map&lt;string, number&gt; {
    const results = new Map&lt;string, number&gt;();
    const color = this.board.getTurn();
    const moves = this.moveGenerator.getLegalMoves(color);

    for (const move of moves) {
      const state = this.board.getState();
      const from = this.board.squareToAlgebraic(move.from);
      const to = this.board.squareToAlgebraic(move.to);
      const moveStr = from + to + (move.promotion || "");

      this.board.makeMove(move);
      const count = this.perft(depth - 1);
      this.board.setState(state);

      results.set(moveStr, count);
    }

    return results;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_types_ts')">üìÑ src/types.ts</button>
<pre id="src_types_ts" class="file-content" style="display:none;"><code class="language-typescript">export type PieceType = "K" | "Q" | "R" | "B" | "N" | "P";
export type Color = "white" | "black";
export type Square = number;

export interface Piece {
  type: PieceType;
  color: Color;
}

export interface Move {
  from: Square;
  to: Square;
  piece: PieceType;
  captured?: PieceType;
  promotion?: PieceType;
  castling?: "K" | "Q" | "k" | "q";
  enPassant?: boolean;
}

export interface CastlingRights {
  whiteKingside: boolean;
  whiteQueenside: boolean;
  blackKingside: boolean;
  blackQueenside: boolean;
}

export interface GameState {
  board: (Piece | null)[];
  turn: Color;
  castlingRights: CastlingRights;
  enPassantTarget: Square | null;
  halfmoveClock: number;
  fullmoveNumber: number;
  moveHistory: Move[];
}

export const PIECE_VALUES: Record&lt;PieceType, number&gt; = {
  P: 100,
  N: 320,
  B: 330,
  R: 500,
  Q: 900,
  K: 20000,
};

export const FILES = ["a", "b", "c", "d", "e", "f", "g", "h"];
export const RANKS = ["1", "2", "3", "4", "5", "6", "7", "8"];
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test_js')">üìÑ test.js</button>
<pre id="test_js" class="file-content" style="display:none;"><code class="language-typescript">const { ChessEngine } = require('./dist/chess.js');
const { Board } = require('./dist/board.js');
const { MoveGenerator } = require('./dist/moveGenerator.js');

const board = new Board();
const moveGen = new MoveGenerator(board);

console.log('Initial board:');
console.log(board.display());

// Try to move e2 to e4
const e2 = board.algebraicToSquare('e2');
const e4 = board.algebraicToSquare('e4');

console.log('e2 square index:', e2);
console.log('e4 square index:', e4);
console.log('Piece at e2:', board.getPiece(e2));

// Get legal moves for white
const moves = moveGen.getLegalMoves('white');
const e2e4Move = moves.find(m =&gt; m.from === e2 &amp;&amp; m.to === e4);
console.log('Found e2e4 move:', e2e4Move);

if (e2e4Move) {
  board.makeMove(e2e4Move);
  console.log('\nAfter e2e4:');
  console.log(board.display());
  console.log('Piece at e4:', board.getPiece(e4));
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test_basic_test_js')">üìÑ test/basic.test.js</button>
<pre id="test_basic_test_js" class="file-content" style="display:none;"><code class="language-typescript">const { spawnSync } = require('child_process');

function runEngine(commands) {
  return spawnSync('node', ['dist/chess.js'], {
    input: commands.join('\n') + '\n',
    encoding: 'utf-8',
  });
}

function assert(condition, message) {
  if (!condition) {
    console.error(message);
    process.exit(1);
  }
}

(function main() {
  const basic = runEngine(['new', 'move e2e4', 'export', 'quit']);
  assert(basic.status === 0, `Engine exited with status ${basic.status}`);
  assert(
    basic.stdout.includes('OK: e2e4'),
    'Expected confirmation for move e2e4',
  );
  assert(/FEN:/i.test(basic.stdout), 'Export command did not produce a FEN');

  const ai = runEngine(['new', 'ai 1', 'quit']);
  assert(ai.status === 0, `AI run exited with status ${ai.status}`);
  assert(/AI:\s*[a-h][1-8][a-h][1-8]/.test(ai.stdout), 'AI did not produce a move indication');
})();
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test2_js')">üìÑ test2.js</button>
<pre id="test2_js" class="file-content" style="display:none;"><code class="language-typescript">const { Board } = require('./dist/board.js');

const board = new Board();

// Check initial positions
console.log('Checking initial positions:');
console.log('White pawns should be at squares 8-15 (rank 1)');
for (let i = 8; i &lt; 16; i++) {
  const piece = board.getPiece(i);
  console.log(`Square ${i} (${board.squareToAlgebraic(i)}):`, piece);
}

console.log('\nBlack pawns should be at squares 48-55 (rank 6)');
for (let i = 48; i &lt; 56; i++) {
  const piece = board.getPiece(i);
  console.log(`Square ${i} (${board.squareToAlgebraic(i)}):`, piece);
}

console.log('\nLet\'s check all squares:');
for (let rank = 7; rank &gt;= 0; rank--) {
  let row = '';
  for (let file = 0; file &lt; 8; file++) {
    const square = rank * 8 + file;
    const piece = board.getPiece(square);
    if (piece) {
      const char = piece.color === 'white' ? piece.type : piece.type.toLowerCase();
      row += char + ' ';
    } else {
      row += '. ';
    }
  }
  console.log(`Rank ${rank + 1}: ${row}`);
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test3_js')">üìÑ test3.js</button>
<pre id="test3_js" class="file-content" style="display:none;"><code class="language-typescript">const { Board } = require('./dist/board.js');
const { MoveGenerator } = require('./dist/moveGenerator.js');

const board = new Board();
const moveGen = new MoveGenerator(board);

console.log('Initial:');
console.log(board.display());

// Make move e2e4
const e2 = board.algebraicToSquare('e2');
const e4 = board.algebraicToSquare('e4');
const moves = moveGen.getLegalMoves('white');
const e2e4 = moves.find(m =&gt; m.from === e2 &amp;&amp; m.to === e4);

console.log('\nMaking move e2e4...');
board.makeMove(e2e4);

console.log('\nAfter move:');
console.log(board.display());

console.log('\nChecking specific squares:');
console.log('e2 (square 12):', board.getPiece(12));
console.log('e4 (square 28):', board.getPiece(28));

console.log('\nManual check of all squares:');
for (let rank = 7; rank &gt;= 0; rank--) {
  let row = `Rank ${rank + 1}: `;
  for (let file = 0; file &lt; 8; file++) {
    const square = rank * 8 + file;
    const piece = board.getPiece(square);
    if (piece) {
      const char = piece.color === 'white' ? piece.type : piece.type.toLowerCase();
      row += char + ' ';
    } else {
      row += '. ';
    }
  }
  console.log(row);
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test4_js')">üìÑ test4.js</button>
<pre id="test4_js" class="file-content" style="display:none;"><code class="language-typescript">const { Board } = require('./dist/board.js');
const { MoveGenerator } = require('./dist/moveGenerator.js');

const board = new Board();
const moveGen = new MoveGenerator(board);

const e2 = board.algebraicToSquare('e2');
console.log('e2 square:', e2);

const piece = board.getPiece(e2);
console.log('Piece at e2:', piece);

const moves = moveGen.generatePieceMoves(e2, piece);
console.log('\nPawn moves from e2:');
moves.forEach(move =&gt; {
  console.log(`  from: ${move.from} (${board.squareToAlgebraic(move.from)}) to: ${move.to} (${board.squareToAlgebraic(move.to)})`);
});

console.log('\nExpected: e2(12) -&gt; e3(20) and e2(12) -&gt; e4(28)');
console.log('e3 should be square:', board.algebraicToSquare('e3'));
console.log('e4 should be square:', board.algebraicToSquare('e4'));</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test5_js')">üìÑ test5.js</button>
<pre id="test5_js" class="file-content" style="display:none;"><code class="language-typescript">const { Board } = require('./dist/board.js');

const board = new Board();

console.log('Before move:');
console.log('Piece at e2 (12):', board.getPiece(12));
console.log('Piece at e4 (28):', board.getPiece(28));

// Manually create move
const move = {
  from: 12,  // e2
  to: 28,    // e4
  piece: 'P'
};

console.log('\nMaking move:', move);
board.makeMove(move);

console.log('\nAfter move:');
console.log('Piece at e2 (12):', board.getPiece(12));
console.log('Piece at e4 (28):', board.getPiece(28));

// Check where all white pawns ended up
console.log('\nWhere are the white pawns?');
for (let i = 0; i &lt; 64; i++) {
  const piece = board.getPiece(i);
  if (piece &amp;&amp; piece.type === 'P' &amp;&amp; piece.color === 'white') {
    console.log(`  White pawn at square ${i} (${board.squareToAlgebraic(i)})`);
  }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test6_js')">üìÑ test6.js</button>
<pre id="test6_js" class="file-content" style="display:none;"><code class="language-typescript">const { Board } = require('./dist/board.js');

const board = new Board();

console.log('Before move - checking display function line by line:');
const displayBefore = board.display();
console.log(displayBefore);

// Make the move
const move = { from: 12, to: 28, piece: 'P' };
board.makeMove(move);

console.log('\nAfter move - checking display function line by line:');
const displayAfter = board.display();
console.log(displayAfter);

console.log('\nChecking board state directly:');
console.log('Turn:', board.getTurn());
console.log('Piece at e4 (28):', board.getPiece(28));

// Verify the display is wrong by checking manually
console.log('\nWhat the display SHOULD show:');
let output = '  a b c d e f g h\n';
for (let rank = 7; rank &gt;= 0; rank--) {
  output += `${rank + 1} `;
  for (let file = 0; file &lt; 8; file++) {
    const square = rank * 8 + file;
    const piece = board.getPiece(square);
    if (piece) {
      const char = piece.color === 'white' 
        ? piece.type 
        : piece.type.toLowerCase();
      output += `${char} `;
    } else {
      output += '. ';
    }
  }
  output += `${rank + 1}\n`;
}
output += '  a b c d e f g h\n\n';
output += `${board.getTurn() === 'white' ? 'White' : 'Black'} to move`;
console.log(output);</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('tsconfig_json')">üìÑ tsconfig.json</button>
<pre id="tsconfig_json" class="file-content" style="display:none;"><code class="language-json">{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}</code></pre>
</div>
</div>

<script>
function toggleFile(id) {
    var content = document.getElementById(id);
    if (content.style.display === 'none') {
        content.style.display = 'block';
        // Highlight the code when first shown
        var codeBlock = content.querySelector('code');
        if (codeBlock && !codeBlock.classList.contains('hljs')) {
            hljs.highlightElement(codeBlock);
        }
    } else {
        content.style.display = 'none';
    }
}
</script>

    </main>
    <footer>
        <p>Generated from benchmark data. All implementations tested via Docker for consistency.</p>
        <p><a href="https://github.com/evaisse/the-great-analysis-challenge">View on GitHub</a></p>
    </footer>
</body>
</html>
