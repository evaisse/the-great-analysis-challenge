<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gleam Source Code - The Great Analysis Challenge</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>üèÜ The Great Analysis Challenge</h1>
        <p class="subtitle">Multi-Language Chess Engine Comparison</p>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/evaisse/the-great-analysis-challenge">GitHub</a>
        </nav>
    </header>
    <main>
<h2>‚≠ê <a href="https://gleam.run/" target="_blank" rel="noopener">Gleam</a> Implementation</h2>
<div class="breadcrumb"><a href="index.html">‚Üê Back to Comparison</a></div>
<div class="file-tree">
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Dockerfile')">üìÑ Dockerfile</button>
<pre id="Dockerfile" class="file-content" style="display:none;"><code class="language-dockerfile">FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies and Erlang from Ubuntu repositories
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    wget \
    ca-certificates \
    build-essential \
    erlang \
    erlang-dev \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install Gleam
RUN GLEAM_VERSION="1.2.1" \
    &amp;&amp; case "$(uname -m)" in \
        x86_64) ARCH="x86_64-unknown-linux-musl" ;; \
        aarch64|arm64) ARCH="aarch64-unknown-linux-musl" ;; \
        *) echo "Unsupported architecture" &amp;&amp; exit 1 ;; \
    esac \
    &amp;&amp; wget "https://github.com/gleam-lang/gleam/releases/download/v${GLEAM_VERSION}/gleam-v${GLEAM_VERSION}-${ARCH}.tar.gz" \
    &amp;&amp; tar -xzf "gleam-v${GLEAM_VERSION}-${ARCH}.tar.gz" \
    &amp;&amp; mv gleam /usr/local/bin/ \
    &amp;&amp; rm "gleam-v${GLEAM_VERSION}-${ARCH}.tar.gz" \
    &amp;&amp; chmod +x /usr/local/bin/gleam

WORKDIR /app

# Copy project files
COPY . .

# Download dependencies and build
RUN gleam deps download &amp;&amp; gleam build

# Set the default command
CMD ["gleam", "run"]</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Makefile')">üìÑ Makefile</button>
<pre id="Makefile" class="file-content" style="display:none;"><code class="language-makefile">.PHONY: all build test analyze clean docker-build docker-test help

# Default target - build the chess engine
all: build

# Build target - compile Gleam project
build:
	gleam build

# Run basic tests
test:
	gleam test
	@echo "Running basic functionality test..."
	@echo -e "new\nmove e2e4\nmove e7e5\nexport\nquit" | gleam run | tail -1 | grep -q "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2" &amp;&amp; echo "‚úÖ Basic test passed" || echo "‚ùå Basic test failed"

# Static analysis and code quality
analyze:
	@echo "Running Gleam static analysis..."
	gleam format --check || true
	gleam check

# Clean build artifacts
clean:
	gleam clean
	rm -rf build/

# Docker targets
docker-build:
	docker build -t chess-gleam .

docker-test: docker-build
	@echo "Testing Gleam implementation in Docker..."
	docker run --rm -i chess-gleam sh -c "echo -e 'new\\nmove e2e4\\nmove e7e5\\nexport\\nquit' | gleam run"

# Help target
help:
	@echo "Available targets:"
	@echo "  make         - Build the chess engine"
	@echo "  make test    - Run tests"
	@echo "  make analyze - Run static analysis"
	@echo "  make clean   - Clean build artifacts"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-test  - Test in Docker"</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('README_md')">üìÑ README.md</button>
<pre id="README_md" class="file-content" style="display:none;"><code class="language-markdown"># Gleam Chess Engine

A complete chess engine implementation in Gleam following the Chess Engine Specification v1.0.

## Features

- Complete chess rules implementation (castling, en passant, promotion)
- AI opponent with minimax algorithm and alpha-beta pruning
- FEN import/export support
- Performance testing with perft
- Functional programming approach with immutable data structures
- Type-safe implementation showcasing Gleam's features

## Local Development

### Prerequisites
- Gleam &gt;= 1.0.0
- Erlang &gt;= 26

### Setup
```bash
gleam run
```

## Docker Usage

### Build the Docker image
```bash
docker build -t chess-gleam .
```

### Run interactively
```bash
docker run -it chess-gleam
```

## Commands

- `move &lt;from&gt;&lt;to&gt;[promotion]` - Make a move (e.g., e2e4, e7e8Q)
- `undo` - Undo the last move
- `new` - Start a new game  
- `ai &lt;depth&gt;` - Let AI make a move (depth 1-5)
- `fen &lt;string&gt;` - Load position from FEN
- `export` - Export current position as FEN
- `eval` - Evaluate current position
- `perft &lt;depth&gt;` - Run performance test
- `help` - Show available commands
- `quit` - Exit the program

## Architecture

- `src/types.gleam` - Core type definitions and constants
- `src/board.gleam` - Board representation and game state
- `src/move_generator.gleam` - Move generation and validation  
- `src/fen.gleam` - FEN parsing and serialization
- `src/ai.gleam` - AI engine with minimax/alpha-beta
- `src/perft.gleam` - Performance testing utilities
- `src/chess_engine.gleam` - Main engine and command interface

## Gleam Language Features

This implementation showcases Gleam's functional programming strengths:

- **Immutable Data Structures**: All game state changes create new instances
- **Pattern Matching**: Elegant piece movement and command parsing
- **Type Safety**: Compile-time guarantees for chess rules
- **Functional Style**: Pure functions with no side effects where possible
- **Result Types**: Proper error handling without exceptions

## Testing

The engine includes perft testing for move generation verification:
```bash
# In the chess engine
perft 4
```

Expected result: 197281 nodes for perft(4) from starting position.

## Implementation Notes

The Gleam chess engine demonstrates functional programming principles:

- All board operations are pure functions returning new game states
- Pattern matching is used extensively for piece movement logic
- Type safety ensures invalid game states cannot be represented
- Recursive algorithms for move generation and AI search
- Immutable data structures prevent accidental state mutations</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('chess_meta')">üìÑ chess.meta</button>
<pre id="chess_meta" class="file-content" style="display:none;"><code class="language-rust">{
  "language": "gleam",
  "version": "1.2.1",
  "author": "Gleam Implementation",
  "build": "gleam build",
  "run": "gleam run",
  "analyze": "gleam format --check &amp;&amp; gleam check",
  "test": "gleam test",
  "features": ["perft", "fen", "ai", "castling", "en_passant", "promotion"],
  "max_ai_depth": 5,
  "estimated_perft4_ms": 800
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('gleam_toml')">üìÑ gleam.toml</button>
<pre id="gleam_toml" class="file-content" style="display:none;"><code class="language-toml">name = "chess_engine"
version = "1.0.0"

[dependencies]
gleam_stdlib = "&gt;= 0.34.0 and &lt; 2.0.0"

[dev-dependencies]
gleeunit = "&gt;= 1.0.0 and &lt; 2.0.0"</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_ai_gleam')">üìÑ src/ai.gleam</button>
<pre id="src_ai_gleam" class="file-content" style="display:none;"><code class="language-rust">// AI engine with minimax and alpha-beta pruning

import gleam/list
import gleam/int
import gleam/option.{None, Some}
import types.{
  type Color, type GameState, type Move, type SearchResult, type PieceType,
  White, Black, Pawn, King, Queen, Rook, Bishop, Knight,
  SearchResult, opposite_color, piece_value
}
import board.{get_piece, make_move}
import move_generator.{get_legal_moves, is_in_check}

pub fn find_best_move(game_state: GameState, depth: Int) -&gt; SearchResult {
  let color = game_state.turn
  let moves = get_legal_moves(game_state, color)
  
  case moves {
    [] -&gt; SearchResult(None, 0, 0, 0)
    [first_move, ..] -&gt; {
      let #(best_move, best_eval, nodes) = 
        list.fold(moves, #(first_move, case color {
          White -&gt; -1000000
          Black -&gt; 1000000
        }, 0), fn(acc, chess_move) {
          let #(current_best, current_eval, current_nodes) = acc
          let new_state = make_move(game_state, chess_move)
          let #(evaluation, move_nodes) = minimax(new_state, depth - 1, -1000000, 1000000, color == Black)
          
          let is_better = case color {
            White -&gt; evaluation &gt; current_eval
            Black -&gt; evaluation &lt; current_eval
          }
          
          case is_better {
            True -&gt; #(chess_move, evaluation, current_nodes + move_nodes)
            False -&gt; #(current_best, current_eval, current_nodes + move_nodes)
          }
        })
      
      SearchResult(Some(best_move), best_eval, nodes, 0)  // Time not tracked in this simple version
    }
  }
}

fn minimax(game_state: GameState, depth: Int, alpha: Int, beta: Int, maximizing: Bool) -&gt; #(Int, Int) {
  case depth &lt;= 0 {
    True -&gt; #(evaluate(game_state), 1)
    False -&gt; {
      let color = game_state.turn
      let moves = get_legal_moves(game_state, color)
      
      case moves {
        [] -&gt; {
          case is_in_check(game_state, color) {
            True -&gt; #(case maximizing {
              True -&gt; -100000
              False -&gt; 100000
            }, 1)
            False -&gt; #(0, 1)  // Stalemate
          }
        }
        _ -&gt; minimax_moves(game_state, moves, depth, alpha, beta, maximizing, 0)
      }
    }
  }
}

fn minimax_moves(game_state: GameState, moves: List(Move), depth: Int, alpha: Int, beta: Int, maximizing: Bool, nodes_acc: Int) -&gt; #(Int, Int) {
  case moves {
    [] -&gt; case maximizing {
      True -&gt; #(-1000000, nodes_acc)
      False -&gt; #(1000000, nodes_acc)
    }
    [move, ..rest_moves] -&gt; {
      let new_state = make_move(game_state, move)
      let #(evaluation, move_nodes) = minimax(new_state, depth - 1, alpha, beta, !maximizing)
      let total_nodes = nodes_acc + move_nodes
      
      case maximizing {
        True -&gt; {
          let new_alpha = int.max(alpha, evaluation)
          case beta &lt;= new_alpha {
            True -&gt; #(evaluation, total_nodes)  // Beta cutoff
            False -&gt; {
              case rest_moves {
                [] -&gt; #(evaluation, total_nodes)
                _ -&gt; {
                  let #(rest_eval, rest_nodes) = minimax_moves(game_state, rest_moves, depth, new_alpha, beta, maximizing, total_nodes)
                  #(int.max(evaluation, rest_eval), rest_nodes)
                }
              }
            }
          }
        }
        False -&gt; {
          let new_beta = int.min(beta, evaluation)
          case new_beta &lt;= alpha {
            True -&gt; #(evaluation, total_nodes)  // Alpha cutoff
            False -&gt; {
              case rest_moves {
                [] -&gt; #(evaluation, total_nodes)
                _ -&gt; {
                  let #(rest_eval, rest_nodes) = minimax_moves(game_state, rest_moves, depth, alpha, new_beta, maximizing, total_nodes)
                  #(int.min(evaluation, rest_eval), rest_nodes)
                }
              }
            }
          }
        }
      }
    }
  }
}

fn evaluate(game_state: GameState) -&gt; Int {
  list.range(0, 63)
    |&gt; list.fold(0, fn(score, square) {
      case get_piece(game_state, square) {
        None -&gt; score
        Some(piece) -&gt; {
          let value = piece_value(piece.piece_type)
          let position_bonus = get_position_bonus(square, piece.piece_type, piece.color, game_state)
          let total_value = value + position_bonus
          
          score + case piece.color {
            White -&gt; total_value
            Black -&gt; -total_value
          }
        }
      }
    })
}

fn get_position_bonus(square: Int, piece_type: PieceType, color: Color, game_state: GameState) -&gt; Int {
  let file = square % 8
  let rank = square / 8
  let bonus = 0
  
  // Center control bonus
  let bonus = case square {
    27 | 28 | 35 | 36 -&gt; bonus + 10  // d4, e4, d5, e5
    _ -&gt; bonus
  }
  
  case piece_type {
    Pawn -&gt; {
      // Pawn advancement bonus
      let advancement = case color {
        White -&gt; rank
        Black -&gt; 7 - rank
      }
      bonus + advancement * 5
    }
    King -&gt; {
      // King safety in opening/middlegame
      case is_endgame(game_state) {
        False -&gt; {
          let safe_rank = case color {
            White -&gt; 0
            Black -&gt; 7
          }
          case rank == safe_rank &amp;&amp; { file &lt;= 2 || file &gt;= 5 } {
            True -&gt; bonus + 20
            False -&gt; bonus - 20
          }
        }
        True -&gt; bonus
      }
    }
    _ -&gt; bonus
  }
}

fn is_endgame(game_state: GameState) -&gt; Bool {
  let #(piece_count, queen_count) = 
    list.range(0, 63)
      |&gt; list.fold(#(0, 0), fn(acc, square) {
        let #(pieces, queens) = acc
        case get_piece(game_state, square) {
          None -&gt; acc
          Some(piece) -&gt; case piece.piece_type {
            King | Pawn -&gt; acc
            Queen -&gt; #(pieces + 1, queens + 1)
            _ -&gt; #(pieces + 1, queens)
          }
        }
      })
  
  piece_count &lt;= 4 || { piece_count &lt;= 6 &amp;&amp; queen_count == 0 }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_board_gleam')">üìÑ src/board.gleam</button>
<pre id="src_board_gleam" class="file-content" style="display:none;"><code class="language-rust">// Board representation and game state management

import gleam/list
import gleam/string
import gleam/int
import gleam/io
import types.{
  type Color, type Piece, type Square, type Move, type PieceType, type GameState,
  type CastlingRights, White, Black, King, Queen, Rook, Bishop, Knight, Pawn,
  Piece, Move, GameState, CastlingRights, new_castling_rights, opposite_color,
  piece_to_char, square_to_algebraic
}

pub fn new_game() -&gt; GameState {
  let board = new_board()
  GameState(
    board: board,
    turn: White,
    castling_rights: new_castling_rights(),
    en_passant_target: None,
    halfmove_clock: 0,
    fullmove_number: 1,
    move_history: [],
  )
}

fn new_board() -&gt; List(Option(Piece)) {
  let empty_row = list.repeat(None, 8)
  let white_pawn_row = list.repeat(Some(Piece(Pawn, White)), 8)
  let black_pawn_row = list.repeat(Some(Piece(Pawn, Black)), 8)
  
  let white_back_row = [
    Some(Piece(Rook, White)),
    Some(Piece(Knight, White)),
    Some(Piece(Bishop, White)),
    Some(Piece(Queen, White)),
    Some(Piece(King, White)),
    Some(Piece(Bishop, White)),
    Some(Piece(Knight, White)),
    Some(Piece(Rook, White)),
  ]
  
  let black_back_row = [
    Some(Piece(Rook, Black)),
    Some(Piece(Knight, Black)),
    Some(Piece(Bishop, Black)),
    Some(Piece(Queen, Black)),
    Some(Piece(King, Black)),
    Some(Piece(Bishop, Black)),
    Some(Piece(Knight, Black)),
    Some(Piece(Rook, Black)),
  ]
  
  list.concat([
    white_back_row,
    white_pawn_row,
    empty_row,
    empty_row,
    empty_row,
    empty_row,
    black_pawn_row,
    black_back_row,
  ])
}

pub fn get_piece(game_state: GameState, square: Square) -&gt; Option(Piece) {
  case list.at(game_state.board, square) {
    Ok(piece) -&gt; piece
    Error(_) -&gt; None
  }
}

pub fn set_piece(game_state: GameState, square: Square, piece: Option(Piece)) -&gt; GameState {
  let new_board = list.index_map(game_state.board, fn(current_piece, index) {
    case index == square {
      True -&gt; piece
      False -&gt; current_piece
    }
  })
  GameState(..game_state, board: new_board)
}

pub fn make_move(game_state: GameState, chess_move: Move) -&gt; GameState {
  let piece = get_piece(game_state, chess_move.from)
  case piece {
    None -&gt; game_state
    Some(moving_piece) -&gt; {
      // Move the piece
      let state_after_move = game_state
        |&gt; set_piece(chess_move.to, Some(moving_piece))
        |&gt; set_piece(chess_move.from, None)
      
      // Handle special moves
      let state_after_special = state_after_move
        |&gt; handle_castling(chess_move, moving_piece)
        |&gt; handle_en_passant(chess_move, moving_piece)
        |&gt; handle_promotion(chess_move, moving_piece)
      
      // Update game state
      let new_castling_rights = update_castling_rights(
        state_after_special.castling_rights,
        chess_move,
        moving_piece,
      )
      
      let new_en_passant = case moving_piece.piece_type == Pawn &amp;&amp; 
                                int.absolute_value(chess_move.to - chess_move.from) == 16 {
        True -&gt; Some({ chess_move.from + chess_move.to } / 2)
        False -&gt; None
      }
      
      let new_halfmove = case moving_piece.piece_type == Pawn || chess_move.captured != None {
        True -&gt; 0
        False -&gt; state_after_special.halfmove_clock + 1
      }
      
      let new_fullmove = case moving_piece.color == Black {
        True -&gt; state_after_special.fullmove_number + 1
        False -&gt; state_after_special.fullmove_number
      }
      
      GameState(
        ..state_after_special,
        turn: opposite_color(moving_piece.color),
        castling_rights: new_castling_rights,
        en_passant_target: new_en_passant,
        halfmove_clock: new_halfmove,
        fullmove_number: new_fullmove,
        move_history: [chess_move, ..state_after_special.move_history],
      )
    }
  }
}

fn handle_castling(game_state: GameState, chess_move: Move, piece: Piece) -&gt; GameState {
  case chess_move.is_castling {
    False -&gt; game_state
    True -&gt; {
      let rank = case piece.color {
        White -&gt; 0
        Black -&gt; 7
      }
      let #(rook_from, rook_to) = case chess_move.to == rank * 8 + 6 {
        True -&gt; #(rank * 8 + 7, rank * 8 + 5)  // Kingside
        False -&gt; #(rank * 8, rank * 8 + 3)     // Queenside
      }
      
      case get_piece(game_state, rook_from) {
        Some(rook) -&gt; game_state
          |&gt; set_piece(rook_to, Some(rook))
          |&gt; set_piece(rook_from, None)
        None -&gt; game_state
      }
    }
  }
}

fn handle_en_passant(game_state: GameState, chess_move: Move, piece: Piece) -&gt; GameState {
  case chess_move.is_en_passant {
    False -&gt; game_state
    True -&gt; {
      let captured_pawn_square = case piece.color {
        White -&gt; chess_move.to - 8
        Black -&gt; chess_move.to + 8
      }
      set_piece(game_state, captured_pawn_square, None)
    }
  }
}

fn handle_promotion(game_state: GameState, chess_move: Move, piece: Piece) -&gt; GameState {
  case chess_move.promotion {
    None -&gt; game_state
    Some(promotion_type) -&gt; 
      set_piece(game_state, chess_move.to, Some(Piece(promotion_type, piece.color)))
  }
}

fn update_castling_rights(
  rights: CastlingRights,
  chess_move: Move,
  piece: Piece,
) -&gt; CastlingRights {
  case piece.piece_type {
    King -&gt; case piece.color {
      White -&gt; CastlingRights(..rights, white_kingside: False, white_queenside: False)
      Black -&gt; CastlingRights(..rights, black_kingside: False, black_queenside: False)
    }
    Rook -&gt; case piece.color, chess_move.from {
      White, 0 -&gt; CastlingRights(..rights, white_queenside: False)
      White, 7 -&gt; CastlingRights(..rights, white_kingside: False)
      Black, 56 -&gt; CastlingRights(..rights, black_queenside: False)
      Black, 63 -&gt; CastlingRights(..rights, black_kingside: False)
      _, _ -&gt; rights
    }
    _ -&gt; rights
  }
}

pub fn undo_move(game_state: GameState) -&gt; GameState {
  case game_state.move_history {
    [] -&gt; game_state
    [last_move, ..rest_history] -&gt; {
      // This is a simplified undo - in a full implementation,
      // we'd need to store more state information
      let piece = get_piece(game_state, last_move.to)
      case piece {
        None -&gt; game_state
        Some(moved_piece) -&gt; {
          let original_piece = case last_move.promotion {
            Some(_) -&gt; Piece(Pawn, moved_piece.color)
            None -&gt; moved_piece
          }
          
          let state_after_undo = game_state
            |&gt; set_piece(last_move.from, Some(original_piece))
            |&gt; set_piece(last_move.to, case last_move.captured {
              Some(captured_type) -&gt; Some(Piece(captured_type, opposite_color(moved_piece.color)))
              None -&gt; None
            })
          
          GameState(
            ..state_after_undo,
            turn: moved_piece.color,
            move_history: rest_history,
          )
        }
      }
    }
  }
}

pub fn display_board(game_state: GameState) -&gt; String {
  let header = "  a b c d e f g h\n"
  let footer = "  a b c d e f g h\n\n"
  let turn_info = case game_state.turn {
    White -&gt; "White to move"
    Black -&gt; "Black to move"
  }
  
  let board_rows = list.range(7, 0)
    |&gt; list.map(fn(rank) {
      let rank_str = int.to_string(rank + 1)
      let row_pieces = list.range(0, 7)
        |&gt; list.map(fn(file) {
          let square = rank * 8 + file
          case get_piece(game_state, square) {
            Some(piece) -&gt; piece_to_char(piece)
            None -&gt; "."
          }
        })
        |&gt; string.join(" ")
      rank_str &lt;&gt; " " &lt;&gt; row_pieces &lt;&gt; " " &lt;&gt; rank_str &lt;&gt; "\n"
    })
    |&gt; string.join("")
  
  header &lt;&gt; board_rows &lt;&gt; footer &lt;&gt; turn_info
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_chess_engine_gleam')">üìÑ src/chess_engine.gleam</button>
<pre id="src_chess_engine_gleam" class="file-content" style="display:none;"><code class="language-rust">// Main chess engine with CLI interface

import gleam/io
import gleam/string
import gleam/list
import gleam/int
import gleam/result
import gleam/option.{None, Some}

@external(erlang, "io", "get_line")
fn get_line(prompt: String) -&gt; String

import types.{
  type GameState, type Move, White, Black,
  algebraic_to_square, square_to_algebraic, opposite_color
}
import board.{new_game, display_board, make_move, undo_move, get_piece}
import move_generator.{get_legal_moves, is_in_check, is_checkmate, is_stalemate}
import fen.{parse_fen, export_fen}
import ai.{find_best_move}
import perft.{perft}

pub type ChessEngine {
  ChessEngine(game_state: GameState)
}

pub fn new() -&gt; ChessEngine {
  ChessEngine(new_game())
}

pub fn main() {
  let engine = new()
  io.println(display_board(engine.game_state))
  game_loop(engine)
}

fn game_loop(engine: ChessEngine) -&gt; Nil {
  let input = get_line("")
  let command = string.trim(input)
  
  case command {
    "quit" -&gt; Nil
    _ -&gt; {
      let new_engine = process_command(engine, command)
      game_loop(new_engine)
    }
  }
}

fn process_command(engine: ChessEngine, command: String) -&gt; ChessEngine {
  let parts = string.split(command, " ")
  case parts {
    ["move", move_str] -&gt; handle_move(engine, move_str)
    ["undo"] -&gt; handle_undo(engine)
    ["new"] -&gt; handle_new(engine)
    ["ai", depth_str] -&gt; handle_ai(engine, depth_str)
    ["fen", ..fen_parts] -&gt; handle_fen(engine, string.join(fen_parts, " "))
    ["export"] -&gt; handle_export(engine)
    ["eval"] -&gt; handle_eval(engine)
    ["perft", depth_str] -&gt; handle_perft(engine, depth_str)
    ["help"] -&gt; handle_help(engine)
    _ -&gt; {
      io.println("ERROR: Invalid command")
      engine
    }
  }
}

fn handle_move(engine: ChessEngine, move_str: String) -&gt; ChessEngine {
  case string.length(move_str) &gt;= 4 {
    False -&gt; {
      io.println("ERROR: Invalid move format")
      engine
    }
    True -&gt; {
      let from_str = string.slice(move_str, 0, 2)
      let to_str = string.slice(move_str, 2, 2)
      let promotion_str = case string.length(move_str) &gt; 4 {
        True -&gt; Some(string.slice(move_str, 4, 1))
        False -&gt; None
      }
      
      case algebraic_to_square(from_str), algebraic_to_square(to_str) {
        Ok(from_square), Ok(to_square) -&gt; {
          case get_piece(engine.game_state, from_square) {
            None -&gt; {
              io.println("ERROR: No piece at source square")
              engine
            }
            Some(piece) -&gt; {
              case piece.color == engine.game_state.turn {
                False -&gt; {
                  io.println("ERROR: Wrong color piece")
                  engine
                }
                True -&gt; {
                  let legal_moves = get_legal_moves(engine.game_state, engine.game_state.turn)
                  let matching_move = find_matching_move(legal_moves, from_square, to_square, promotion_str)
                  
                  case matching_move {
                    None -&gt; {
                      case is_in_check(engine.game_state, engine.game_state.turn) {
                        True -&gt; io.println("ERROR: King would be in check")
                        False -&gt; io.println("ERROR: Illegal move")
                      }
                      engine
                    }
                    Some(chess_move) -&gt; {
                      let new_state = make_move(engine.game_state, chess_move)
                      io.println("OK: " &lt;&gt; move_str)
                      io.println(display_board(new_state))
                      check_game_end(new_state)
                      ChessEngine(new_state)
                    }
                  }
                }
              }
            }
          }
        }
        _, _ -&gt; {
          io.println("ERROR: Invalid move format")
          engine
        }
      }
    }
  }
}

fn find_matching_move(moves: List(Move), from: Int, to: Int, promotion_str: Option(String)) -&gt; Option(Move) {
  list.find(moves, fn(chess_move) {
    chess_move.from == from &amp;&amp; chess_move.to == to &amp;&amp;
    case chess_move.promotion, promotion_str {
      Some(types.Queen), None -&gt; True
      Some(types.Queen), Some("Q") | Some(types.Queen), Some("q") -&gt; True
      Some(types.Rook), Some("R") | Some(types.Rook), Some("r") -&gt; True
      Some(types.Bishop), Some("B") | Some(types.Bishop), Some("b") -&gt; True
      Some(types.Knight), Some("N") | Some(types.Knight), Some("n") -&gt; True
      None, None -&gt; True
      _, _ -&gt; False
    }
  })
  |&gt; result.to_option
}

fn handle_undo(engine: ChessEngine) -&gt; ChessEngine {
  case engine.game_state.move_history {
    [] -&gt; {
      io.println("ERROR: No moves to undo")
      engine
    }
    _ -&gt; {
      let new_state = undo_move(engine.game_state)
      io.println("Move undone")
      io.println(display_board(new_state))
      ChessEngine(new_state)
    }
  }
}

fn handle_new(engine: ChessEngine) -&gt; ChessEngine {
  let new_state = new_game()
  io.println("New game started")
  io.println(display_board(new_state))
  ChessEngine(new_state)
}

fn handle_ai(engine: ChessEngine, depth_str: String) -&gt; ChessEngine {
  case int.parse(depth_str) {
    Error(_) -&gt; {
      io.println("ERROR: AI depth must be 1-5")
      engine
    }
    Ok(depth) if depth &lt; 1 || depth &gt; 5 -&gt; {
      io.println("ERROR: AI depth must be 1-5")
      engine
    }
    Ok(depth) -&gt; {
      let result = find_best_move(engine.game_state, depth)
      case result.best_move {
        None -&gt; {
          io.println("ERROR: No legal moves available")
          engine
        }
        Some(chess_move) -&gt; {
          let move_str = square_to_algebraic(chess_move.from) &lt;&gt;
                        square_to_algebraic(chess_move.to) &lt;&gt;
                        case chess_move.promotion {
                          Some(types.Queen) -&gt; "Q"
                          Some(types.Rook) -&gt; "R"
                          Some(types.Bishop) -&gt; "B"
                          Some(types.Knight) -&gt; "N"
                          _ -&gt; ""
                        }
          
          let new_state = make_move(engine.game_state, chess_move)
          io.println("AI: " &lt;&gt; move_str &lt;&gt; " (depth=" &lt;&gt; int.to_string(depth) &lt;&gt; 
                    ", eval=" &lt;&gt; int.to_string(result.evaluation) &lt;&gt; 
                    ", time=" &lt;&gt; int.to_string(result.time_ms) &lt;&gt; "ms)")
          io.println(display_board(new_state))
          check_game_end(new_state)
          ChessEngine(new_state)
        }
      }
    }
  }
}

fn handle_fen(engine: ChessEngine, fen_string: String) -&gt; ChessEngine {
  case parse_fen(fen_string) {
    Error(err) -&gt; {
      io.println(err)
      engine
    }
    Ok(new_state) -&gt; {
      io.println("Position loaded from FEN")
      io.println(display_board(new_state))
      ChessEngine(new_state)
    }
  }
}

fn handle_export(engine: ChessEngine) -&gt; ChessEngine {
  let fen = export_fen(engine.game_state)
  io.println("FEN: " &lt;&gt; fen)
  engine
}

fn handle_eval(engine: ChessEngine) -&gt; ChessEngine {
  let result = find_best_move(engine.game_state, 1)
  io.println("Position evaluation: " &lt;&gt; int.to_string(result.evaluation))
  engine
}

fn handle_perft(engine: ChessEngine, depth_str: String) -&gt; ChessEngine {
  case int.parse(depth_str) {
    Error(_) -&gt; {
      io.println("ERROR: Invalid perft depth")
      engine
    }
    Ok(depth) if depth &lt; 1 -&gt; {
      io.println("ERROR: Invalid perft depth")
      engine
    }
    Ok(depth) -&gt; {
      let nodes = perft(engine.game_state, depth)
      io.println("Perft(" &lt;&gt; int.to_string(depth) &lt;&gt; "): " &lt;&gt; 
                int.to_string(nodes) &lt;&gt; " nodes (0ms)")
      engine
    }
  }
}

fn handle_help(engine: ChessEngine) -&gt; ChessEngine {
  io.println("Available commands:")
  io.println("  move &lt;from&gt;&lt;to&gt;[promotion] - Make a move (e.g., e2e4, e7e8Q)")
  io.println("  undo - Undo the last move")
  io.println("  new - Start a new game")
  io.println("  ai &lt;depth&gt; - Let AI make a move (depth 1-5)")
  io.println("  fen &lt;string&gt; - Load position from FEN")
  io.println("  export - Export current position as FEN")
  io.println("  eval - Evaluate current position")
  io.println("  perft &lt;depth&gt; - Run performance test")
  io.println("  help - Show this help message")
  io.println("  quit - Exit the program")
  engine
}

fn check_game_end(game_state: GameState) -&gt; Nil {
  let color = game_state.turn
  let legal_moves = get_legal_moves(game_state, color)
  
  case list.is_empty(legal_moves) {
    False -&gt; Nil
    True -&gt; {
      case is_in_check(game_state, color) {
        True -&gt; {
          let winner = case color {
            White -&gt; "Black"
            Black -&gt; "White"
          }
          io.println("CHECKMATE: " &lt;&gt; winner &lt;&gt; " wins")
        }
        False -&gt; io.println("STALEMATE: Draw")
      }
    }
  }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_fen_gleam')">üìÑ src/fen.gleam</button>
<pre id="src_fen_gleam" class="file-content" style="display:none;"><code class="language-rust">// FEN parsing and export functionality

import gleam/list
import gleam/string
import gleam/int
import gleam/result
import types.{
  type Color, type GameState, type CastlingRights, White, Black,
  CastlingRights, GameState, char_to_piece, piece_to_char,
  algebraic_to_square, square_to_algebraic, no_castling_rights
}
import board.{get_piece, set_piece}

pub fn parse_fen(fen: String) -&gt; Result(GameState, String) {
  let parts = string.split(fen, " ")
  case parts {
    [pieces, turn, castling, en_passant, halfmove, fullmove] -&gt;
      parse_fen_parts(pieces, turn, castling, en_passant, halfmove, fullmove)
    [pieces, turn, castling, en_passant] -&gt;
      parse_fen_parts(pieces, turn, castling, en_passant, "0", "1")
    _ -&gt; Error("ERROR: Invalid FEN string")
  }
}

fn parse_fen_parts(
  pieces: String,
  turn: String,
  castling: String,
  en_passant: String,
  halfmove: String,
  fullmove: String,
) -&gt; Result(GameState, String) {
  use board &lt;- result.try(parse_pieces(pieces))
  use color &lt;- result.try(parse_turn(turn))
  use rights &lt;- result.try(parse_castling_rights(castling))
  use en_passant_target &lt;- result.try(parse_en_passant(en_passant))
  use halfmove_clock &lt;- result.try(parse_int(halfmove, "halfmove"))
  use fullmove_number &lt;- result.try(parse_int(fullmove, "fullmove"))
  
  Ok(GameState(
    board: board,
    turn: color,
    castling_rights: rights,
    en_passant_target: en_passant_target,
    halfmove_clock: halfmove_clock,
    fullmove_number: fullmove_number,
    move_history: [],
  ))
}

fn parse_pieces(pieces: String) -&gt; Result(List(Option(types.Piece)), String) {
  let ranks = string.split(pieces, "/")
  case list.length(ranks) {
    8 -&gt; {
      ranks
        |&gt; list.reverse  // FEN starts from rank 8, we need to start from rank 1
        |&gt; list.try_map(parse_rank)
        |&gt; result.map(list.flatten)
        |&gt; result.map_error(fn(_) { "ERROR: Invalid FEN string" })
    }
    _ -&gt; Error("ERROR: Invalid FEN string")
  }
}

fn parse_rank(rank: String) -&gt; Result(List(Option(types.Piece)), Nil) {
  rank
    |&gt; string.to_graphemes
    |&gt; list.try_fold([], fn(acc, char) {
      case int.parse(char) {
        Ok(num) if num &gt;= 1 &amp;&amp; num &lt;= 8 -&gt; {
          let empty_squares = list.repeat(None, num)
          Ok(list.concat([acc, empty_squares]))
        }
        Error(_) -&gt; {
          case char_to_piece(char) {
            Some(piece) -&gt; Ok([Some(piece), ..acc])
            None -&gt; Error(Nil)
          }
        }
      }
    })
    |&gt; result.map(list.reverse)
}

fn parse_turn(turn: String) -&gt; Result(Color, String) {
  case turn {
    "w" -&gt; Ok(White)
    "b" -&gt; Ok(Black)
    _ -&gt; Error("ERROR: Invalid FEN string")
  }
}

fn parse_castling_rights(castling: String) -&gt; Result(CastlingRights, String) {
  case castling {
    "-" -&gt; Ok(no_castling_rights())
    _ -&gt; {
      let rights = no_castling_rights()
      let white_kingside = string.contains(castling, "K")
      let white_queenside = string.contains(castling, "Q")
      let black_kingside = string.contains(castling, "k")
      let black_queenside = string.contains(castling, "q")
      
      Ok(CastlingRights(
        white_kingside: white_kingside,
        white_queenside: white_queenside,
        black_kingside: black_kingside,
        black_queenside: black_queenside,
      ))
    }
  }
}

fn parse_en_passant(en_passant: String) -&gt; Result(Option(Int), String) {
  case en_passant {
    "-" -&gt; Ok(None)
    _ -&gt; {
      algebraic_to_square(en_passant)
        |&gt; result.map(Some)
        |&gt; result.map_error(fn(_) { "ERROR: Invalid FEN string" })
    }
  }
}

fn parse_int(str: String, field: String) -&gt; Result(Int, String) {
  int.parse(str)
    |&gt; result.map_error(fn(_) { "ERROR: Invalid FEN string" })
}

pub fn export_fen(game_state: GameState) -&gt; String {
  let pieces = export_pieces(game_state)
  let turn = case game_state.turn {
    White -&gt; "w"
    Black -&gt; "b"
  }
  let castling = export_castling_rights(game_state.castling_rights)
  let en_passant = export_en_passant(game_state.en_passant_target)
  let halfmove = int.to_string(game_state.halfmove_clock)
  let fullmove = int.to_string(game_state.fullmove_number)
  
  pieces &lt;&gt; " " &lt;&gt; turn &lt;&gt; " " &lt;&gt; castling &lt;&gt; " " &lt;&gt; en_passant &lt;&gt; " " &lt;&gt; halfmove &lt;&gt; " " &lt;&gt; fullmove
}

fn export_pieces(game_state: GameState) -&gt; String {
  list.range(7, 0)  // Start from rank 8 down to rank 1
    |&gt; list.map(fn(rank) {
      list.range(0, 7)  // Files a to h
        |&gt; list.map(fn(file) {
          let square = rank * 8 + file
          get_piece(game_state, square)
        })
        |&gt; export_rank
    })
    |&gt; string.join("/")
}

fn export_rank(rank_pieces: List(Option(types.Piece))) -&gt; String {
  rank_pieces
    |&gt; list.fold([], fn(acc, piece) {
      case acc, piece {
        [], None -&gt; [1]
        [head, ..tail], None if is_int(head) -&gt; [head + 1, ..tail]
        _, None -&gt; [1, ..acc]
        _, Some(p) -&gt; [piece_to_char(p), ..acc]
      }
    })
    |&gt; list.reverse
    |&gt; list.map(fn(item) {
      case is_string(item) {
        True -&gt; item
        False -&gt; int.to_string(item)
      }
    })
    |&gt; string.join("")
}

fn export_castling_rights(rights: CastlingRights) -&gt; String {
  let castling_chars = []
  let castling_chars = case rights.white_kingside {
    True -&gt; ["K", ..castling_chars]
    False -&gt; castling_chars
  }
  let castling_chars = case rights.white_queenside {
    True -&gt; ["Q", ..castling_chars]
    False -&gt; castling_chars
  }
  let castling_chars = case rights.black_kingside {
    True -&gt; ["k", ..castling_chars]
    False -&gt; castling_chars
  }
  let castling_chars = case rights.black_queenside {
    True -&gt; ["q", ..castling_chars]
    False -&gt; castling_chars
  }
  
  case castling_chars {
    [] -&gt; "-"
    _ -&gt; castling_chars |&gt; list.reverse |&gt; string.join("")
  }
}

fn export_en_passant(en_passant_target: Option(Int)) -&gt; String {
  case en_passant_target {
    None -&gt; "-"
    Some(square) -&gt; square_to_algebraic(square)
  }
}

// Helper functions to check types (Gleam doesn't have built-in type checking)
external fn is_int(value: a) -&gt; Bool =
  "erlang" "is_integer"

external fn is_string(value: a) -&gt; Bool =
  "erlang" "is_binary"</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_move_generator_gleam')">üìÑ src/move_generator.gleam</button>
<pre id="src_move_generator_gleam" class="file-content" style="display:none;"><code class="language-rust">// Move generation and validation

import gleam/list
import gleam/int
import types.{
  type Color, type Piece, type Square, type Move, type PieceType, type GameState,
  type CastlingRights, White, Black, King, Queen, Rook, Bishop, Knight, Pawn,
  Piece, Move, opposite_color
}
import board.{get_piece, make_move}

pub fn generate_moves(game_state: GameState, color: Color) -&gt; List(Move) {
  list.range(0, 63)
    |&gt; list.flat_map(fn(square) {
      case get_piece(game_state, square) {
        Some(piece) if piece.color == color -&gt;
          generate_piece_moves(game_state, square, piece)
        _ -&gt; []
      }
    })
}

fn generate_piece_moves(game_state: GameState, from: Square, piece: Piece) -&gt; List(Move) {
  case piece.piece_type {
    Pawn -&gt; generate_pawn_moves(game_state, from, piece.color)
    Knight -&gt; generate_knight_moves(game_state, from, piece.color)
    Bishop -&gt; generate_bishop_moves(game_state, from, piece.color)
    Rook -&gt; generate_rook_moves(game_state, from, piece.color)
    Queen -&gt; generate_queen_moves(game_state, from, piece.color)
    King -&gt; generate_king_moves(game_state, from, piece.color)
  }
}

fn generate_pawn_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  let direction = case color {
    White -&gt; 8
    Black -&gt; -8
  }
  let start_rank = case color {
    White -&gt; 1
    Black -&gt; 6
  }
  let promotion_rank = case color {
    White -&gt; 7
    Black -&gt; 0
  }
  
  let rank = from / 8
  let file = from % 8
  let moves = []
  
  // One square forward
  let one_forward = from + direction
  let moves = case is_valid_square(one_forward) &amp;&amp; get_piece(game_state, one_forward) == None {
    True -&gt; {
      let to_rank = one_forward / 8
      case to_rank == promotion_rank {
        True -&gt; [
          Move(from, one_forward, Pawn, None, Some(Queen), False, False),
          Move(from, one_forward, Pawn, None, Some(Rook), False, False),
          Move(from, one_forward, Pawn, None, Some(Bishop), False, False),
          Move(from, one_forward, Pawn, None, Some(Knight), False, False),
          ..moves
        ]
        False -&gt; [Move(from, one_forward, Pawn, None, None, False, False), ..moves]
      }
    }
    False -&gt; moves
  }
  
  // Two squares forward from starting position
  let moves = case rank == start_rank &amp;&amp; get_piece(game_state, from + 2 * direction) == None {
    True -&gt; [Move(from, from + 2 * direction, Pawn, None, None, False, False), ..moves]
    False -&gt; moves
  }
  
  // Captures
  let capture_moves = [direction - 1, direction + 1]
    |&gt; list.flat_map(fn(offset) {
      let to = from + offset
      let to_file = to % 8
      case is_valid_square(to) &amp;&amp; int.absolute_value(to_file - file) == 1 {
        True -&gt; {
          case get_piece(game_state, to) {
            Some(target) if target.color != color -&gt; {
              let to_rank = to / 8
              case to_rank == promotion_rank {
                True -&gt; [
                  Move(from, to, Pawn, Some(target.piece_type), Some(Queen), False, False),
                  Move(from, to, Pawn, Some(target.piece_type), Some(Rook), False, False),
                  Move(from, to, Pawn, Some(target.piece_type), Some(Bishop), False, False),
                  Move(from, to, Pawn, Some(target.piece_type), Some(Knight), False, False),
                ]
                False -&gt; [Move(from, to, Pawn, Some(target.piece_type), None, False, False)]
              }
            }
            _ -&gt; []
          }
        }
        False -&gt; []
      }
    })
  
  // En passant
  let en_passant_moves = case game_state.en_passant_target {
    Some(en_passant_square) -&gt; {
      let expected_rank = case color {
        White -&gt; 4
        Black -&gt; 3
      }
      case rank == expected_rank {
        True -&gt; [direction - 1, direction + 1]
          |&gt; list.filter_map(fn(offset) {
            let to = from + offset
            case to == en_passant_square {
              True -&gt; Ok(Move(from, to, Pawn, Some(Pawn), None, False, True))
              False -&gt; Error(Nil)
            }
          })
        False -&gt; []
      }
    }
    None -&gt; []
  }
  
  list.concat([moves, capture_moves, en_passant_moves])
}

fn generate_knight_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  let offsets = [-17, -15, -10, -6, 6, 10, 15, 17]
  let file = from % 8
  
  offsets
    |&gt; list.filter_map(fn(offset) {
      let to = from + offset
      let to_file = to % 8
      case is_valid_square(to) &amp;&amp; int.absolute_value(to_file - file) &lt;= 2 {
        True -&gt; {
          case get_piece(game_state, to) {
            None -&gt; Ok(Move(from, to, Knight, None, None, False, False))
            Some(target) if target.color != color -&gt;
              Ok(Move(from, to, Knight, Some(target.piece_type), None, False, False))
            _ -&gt; Error(Nil)
          }
        }
        False -&gt; Error(Nil)
      }
    })
}

fn generate_sliding_moves(game_state: GameState, from: Square, color: Color, directions: List(Int), piece_type: PieceType) -&gt; List(Move) {
  directions
    |&gt; list.flat_map(fn(direction) {
      generate_direction_moves(game_state, from, color, direction, piece_type, [])
    })
}

fn generate_direction_moves(game_state: GameState, from: Square, color: Color, direction: Int, piece_type: PieceType, acc: List(Move)) -&gt; List(Move) {
  let to = from + direction
  let from_file = from % 8
  let to_file = to % 8
  
  case is_valid_square(to) {
    False -&gt; acc
    True -&gt; {
      // Check for wrapping on horizontal moves
      case direction == -1 || direction == 1 {
        True if int.absolute_value(to_file - from_file) != 1 -&gt; acc
        _ -&gt; {
          case get_piece(game_state, to) {
            None -&gt; {
              let new_move = Move(from, to, piece_type, None, None, False, False)
              generate_direction_moves(game_state, to, color, direction, piece_type, [new_move, ..acc])
            }
            Some(target) if target.color != color -&gt; {
              let capture_move = Move(from, to, piece_type, Some(target.piece_type), None, False, False)
              [capture_move, ..acc]
            }
            _ -&gt; acc
          }
        }
      }
    }
  }
}

fn generate_bishop_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  generate_sliding_moves(game_state, from, color, [-9, -7, 7, 9], Bishop)
}

fn generate_rook_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  generate_sliding_moves(game_state, from, color, [-8, -1, 1, 8], Rook)
}

fn generate_queen_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  generate_sliding_moves(game_state, from, color, [-9, -8, -7, -1, 1, 7, 8, 9], Queen)
}

fn generate_king_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  let offsets = [-9, -8, -7, -1, 1, 7, 8, 9]
  let file = from % 8
  
  let normal_moves = offsets
    |&gt; list.filter_map(fn(offset) {
      let to = from + offset
      let to_file = to % 8
      case is_valid_square(to) &amp;&amp; int.absolute_value(to_file - file) &lt;= 1 {
        True -&gt; {
          case get_piece(game_state, to) {
            None -&gt; Ok(Move(from, to, King, None, None, False, False))
            Some(target) if target.color != color -&gt;
              Ok(Move(from, to, King, Some(target.piece_type), None, False, False))
            _ -&gt; Error(Nil)
          }
        }
        False -&gt; Error(Nil)
      }
    })
  
  // Add castling moves
  let castling_moves = generate_castling_moves(game_state, from, color)
  
  list.concat([normal_moves, castling_moves])
}

fn generate_castling_moves(game_state: GameState, from: Square, color: Color) -&gt; List(Move) {
  let moves = []
  
  case color, from {
    White, 4 -&gt; {
      let moves = case game_state.castling_rights.white_kingside &amp;&amp;
                       get_piece(game_state, 5) == None &amp;&amp;
                       get_piece(game_state, 6) == None &amp;&amp;
                       is_rook_at(game_state, 7, White) &amp;&amp;
                       !is_square_attacked(game_state, 4, Black) &amp;&amp;
                       !is_square_attacked(game_state, 5, Black) &amp;&amp;
                       !is_square_attacked(game_state, 6, Black) {
        True -&gt; [Move(4, 6, King, None, None, True, False), ..moves]
        False -&gt; moves
      }
      
      case game_state.castling_rights.white_queenside &amp;&amp;
           get_piece(game_state, 3) == None &amp;&amp;
           get_piece(game_state, 2) == None &amp;&amp;
           get_piece(game_state, 1) == None &amp;&amp;
           is_rook_at(game_state, 0, White) &amp;&amp;
           !is_square_attacked(game_state, 4, Black) &amp;&amp;
           !is_square_attacked(game_state, 3, Black) &amp;&amp;
           !is_square_attacked(game_state, 2, Black) {
        True -&gt; [Move(4, 2, King, None, None, True, False), ..moves]
        False -&gt; moves
      }
    }
    Black, 60 -&gt; {
      let moves = case game_state.castling_rights.black_kingside &amp;&amp;
                       get_piece(game_state, 61) == None &amp;&amp;
                       get_piece(game_state, 62) == None &amp;&amp;
                       is_rook_at(game_state, 63, Black) &amp;&amp;
                       !is_square_attacked(game_state, 60, White) &amp;&amp;
                       !is_square_attacked(game_state, 61, White) &amp;&amp;
                       !is_square_attacked(game_state, 62, White) {
        True -&gt; [Move(60, 62, King, None, None, True, False), ..moves]
        False -&gt; moves
      }
      
      case game_state.castling_rights.black_queenside &amp;&amp;
           get_piece(game_state, 59) == None &amp;&amp;
           get_piece(game_state, 58) == None &amp;&amp;
           get_piece(game_state, 57) == None &amp;&amp;
           is_rook_at(game_state, 56, Black) &amp;&amp;
           !is_square_attacked(game_state, 60, White) &amp;&amp;
           !is_square_attacked(game_state, 59, White) &amp;&amp;
           !is_square_attacked(game_state, 58, White) {
        True -&gt; [Move(60, 58, King, None, None, True, False), ..moves]
        False -&gt; moves
      }
    }
    _, _ -&gt; moves
  }
}

fn is_rook_at(game_state: GameState, square: Square, color: Color) -&gt; Bool {
  case get_piece(game_state, square) {
    Some(Piece(Rook, piece_color)) if piece_color == color -&gt; True
    _ -&gt; False
  }
}

pub fn is_square_attacked(game_state: GameState, square: Square, by_color: Color) -&gt; Bool {
  list.range(0, 63)
    |&gt; list.any(fn(from_square) {
      case get_piece(game_state, from_square) {
        Some(piece) if piece.color == by_color -&gt; {
          let moves = generate_piece_moves(game_state, from_square, piece)
          list.any(moves, fn(move) { move.to == square })
        }
        _ -&gt; False
      }
    })
}

pub fn is_in_check(game_state: GameState, color: Color) -&gt; Bool {
  list.range(0, 63)
    |&gt; list.find_map(fn(square) {
      case get_piece(game_state, square) {
        Some(Piece(King, king_color)) if king_color == color -&gt; Ok(square)
        _ -&gt; Error(Nil)
      }
    })
    |&gt; case {
      Ok(king_square) -&gt; is_square_attacked(game_state, king_square, opposite_color(color))
      Error(_) -&gt; False
    }
}

pub fn get_legal_moves(game_state: GameState, color: Color) -&gt; List(Move) {
  generate_moves(game_state, color)
    |&gt; list.filter(fn(move) {
      let new_state = make_move(game_state, move)
      !is_in_check(new_state, color)
    })
}

pub fn is_checkmate(game_state: GameState, color: Color) -&gt; Bool {
  is_in_check(game_state, color) &amp;&amp; list.is_empty(get_legal_moves(game_state, color))
}

pub fn is_stalemate(game_state: GameState, color: Color) -&gt; Bool {
  !is_in_check(game_state, color) &amp;&amp; list.is_empty(get_legal_moves(game_state, color))
}

fn is_valid_square(square: Square) -&gt; Bool {
  square &gt;= 0 &amp;&amp; square &lt; 64
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_perft_gleam')">üìÑ src/perft.gleam</button>
<pre id="src_perft_gleam" class="file-content" style="display:none;"><code class="language-rust">// Performance testing utilities

import gleam/list
import types.{type GameState}
import board.{make_move}
import move_generator.{get_legal_moves}

pub fn perft(game_state: GameState, depth: Int) -&gt; Int {
  case depth &lt;= 0 {
    True -&gt; 1
    False -&gt; {
      let color = game_state.turn
      let moves = get_legal_moves(game_state, color)
      
      moves
        |&gt; list.map(fn(chess_move) {
          let new_state = make_move(game_state, chess_move)
          perft(new_state, depth - 1)
        })
        |&gt; list.fold(0, fn(acc, count) { acc + count })
    }
  }
}

pub fn perft_divide(game_state: GameState, depth: Int) -&gt; List(#(String, Int)) {
  let color = game_state.turn
  let moves = get_legal_moves(game_state, color)
  
  moves
    |&gt; list.map(fn(chess_move) {
      let move_str = move_to_string(chess_move)
      let new_state = make_move(game_state, chess_move)
      let count = perft(new_state, depth - 1)
      #(move_str, count)
    })
}

fn move_to_string(chess_move: types.Move) -&gt; String {
  let from_str = types.square_to_algebraic(chess_move.from)
  let to_str = types.square_to_algebraic(chess_move.to)
  let promotion_str = case chess_move.promotion {
    Some(types.Queen) -&gt; "Q"
    Some(types.Rook) -&gt; "R"
    Some(types.Bishop) -&gt; "B"
    Some(types.Knight) -&gt; "N"
    _ -&gt; ""
  }
  from_str &lt;&gt; to_str &lt;&gt; promotion_str
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_types_gleam')">üìÑ src/types.gleam</button>
<pre id="src_types_gleam" class="file-content" style="display:none;"><code class="language-rust">// Core chess types and data structures

import gleam/string
import gleam/int

pub type Color {
  White
  Black
}

pub type PieceType {
  King
  Queen
  Rook
  Bishop
  Knight
  Pawn
}

pub type Piece {
  Piece(piece_type: PieceType, color: Color)
}

pub type Square =
  Int

pub type Move {
  Move(
    from: Square,
    to: Square,
    piece: PieceType,
    captured: Option(PieceType),
    promotion: Option(PieceType),
    is_castling: Bool,
    is_en_passant: Bool,
  )
}

pub type CastlingRights {
  CastlingRights(
    white_kingside: Bool,
    white_queenside: Bool,
    black_kingside: Bool,
    black_queenside: Bool,
  )
}

pub type GameState {
  GameState(
    board: List(Option(Piece)),
    turn: Color,
    castling_rights: CastlingRights,
    en_passant_target: Option(Square),
    halfmove_clock: Int,
    fullmove_number: Int,
    move_history: List(Move),
  )
}

pub type SearchResult {
  SearchResult(
    best_move: Option(Move),
    evaluation: Int,
    nodes: Int,
    time_ms: Int,
  )
}

pub fn opposite_color(color: Color) -&gt; Color {
  case color {
    White -&gt; Black
    Black -&gt; White
  }
}

pub fn piece_value(piece_type: PieceType) -&gt; Int {
  case piece_type {
    Pawn -&gt; 100
    Knight -&gt; 320
    Bishop -&gt; 330
    Rook -&gt; 500
    Queen -&gt; 900
    King -&gt; 20000
  }
}

pub fn piece_to_char(piece: Piece) -&gt; String {
  let char = case piece.piece_type {
    King -&gt; "K"
    Queen -&gt; "Q"
    Rook -&gt; "R"
    Bishop -&gt; "B"
    Knight -&gt; "N"
    Pawn -&gt; "P"
  }
  case piece.color {
    White -&gt; char
    Black -&gt; string.lowercase(char)
  }
}

pub fn char_to_piece(char: String) -&gt; Option(Piece) {
  let upper_char = string.uppercase(char)
  let piece_type = case upper_char {
    "K" -&gt; Ok(King)
    "Q" -&gt; Ok(Queen)
    "R" -&gt; Ok(Rook)
    "B" -&gt; Ok(Bishop)
    "N" -&gt; Ok(Knight)
    "P" -&gt; Ok(Pawn)
    _ -&gt; Error(Nil)
  }
  
  case piece_type {
    Ok(pt) -&gt; {
      let color = case char == upper_char {
        True -&gt; White
        False -&gt; Black
      }
      Some(Piece(pt, color))
    }
    Error(_) -&gt; None
  }
}

pub fn square_to_algebraic(square: Square) -&gt; String {
  let file = square % 8
  let rank = square / 8
  let file_char = case file {
    0 -&gt; "a"
    1 -&gt; "b"
    2 -&gt; "c"
    3 -&gt; "d"
    4 -&gt; "e"
    5 -&gt; "f"
    6 -&gt; "g"
    7 -&gt; "h"
    _ -&gt; ""
  }
  let rank_char = int.to_string(rank + 1)
  file_char &lt;&gt; rank_char
}

pub fn algebraic_to_square(algebraic: String) -&gt; Result(Square, Nil) {
  case string.length(algebraic) {
    2 -&gt; {
      let chars = string.to_graphemes(algebraic)
      case chars {
        [file_char, rank_char] -&gt; {
          let file = case file_char {
            "a" -&gt; Ok(0)
            "b" -&gt; Ok(1)
            "c" -&gt; Ok(2)
            "d" -&gt; Ok(3)
            "e" -&gt; Ok(4)
            "f" -&gt; Ok(5)
            "g" -&gt; Ok(6)
            "h" -&gt; Ok(7)
            _ -&gt; Error(Nil)
          }
          let rank = case int.parse(rank_char) {
            Ok(r) if r &gt;= 1 &amp;&amp; r &lt;= 8 -&gt; Ok(r - 1)
            _ -&gt; Error(Nil)
          }
          case file, rank {
            Ok(f), Ok(r) -&gt; Ok(r * 8 + f)
            _, _ -&gt; Error(Nil)
          }
        }
        _ -&gt; Error(Nil)
      }
    }
    _ -&gt; Error(Nil)
  }
}

pub fn new_castling_rights() -&gt; CastlingRights {
  CastlingRights(True, True, True, True)
}

pub fn no_castling_rights() -&gt; CastlingRights {
  CastlingRights(False, False, False, False)
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test_chess_engine_test_gleam')">üìÑ test/chess_engine_test.gleam</button>
<pre id="test_chess_engine_test_gleam" class="file-content" style="display:none;"><code class="language-rust">import gleeunit
import gleeunit/should
import gleam/list
import types.{White, Black}
import board.{new_game, get_piece}
import move_generator.{get_legal_moves}
import fen.{parse_fen, export_fen}
import chess_engine.{new}

pub fn main() {
  gleeunit.main()
}

// Test basic game initialization
pub fn new_game_test() {
  let game = new_game()
  game.turn
  |&gt; should.equal(White)
}

// Test that a new chess engine can be created
pub fn new_engine_test() {
  let engine = new()
  engine.game_state.turn
  |&gt; should.equal(White)
}

// Test legal moves from starting position
pub fn starting_position_moves_test() {
  let game = new_game()
  let legal_moves = get_legal_moves(game, White)
  
  // Starting position should have 20 legal moves
  legal_moves
  |&gt; list.length
  |&gt; should.equal(20)
}

// Test FEN export/import
pub fn fen_export_import_test() {
  let game = new_game()
  let fen = export_fen(game)
  
  // Starting position FEN
  fen
  |&gt; should.equal("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
  
  // Test importing the same FEN
  case parse_fen(fen) {
    Ok(imported_game) -&gt; {
      export_fen(imported_game)
      |&gt; should.equal(fen)
    }
    Error(_) -&gt; should.fail()
  }
}

// Test piece placement
pub fn piece_placement_test() {
  let game = new_game()
  
  // Test white king is at e1
  case get_piece(game, 4) {  // e1 = 4
    Some(piece) -&gt; {
      piece.piece_type
      |&gt; should.equal(types.King)
      piece.color
      |&gt; should.equal(White)
    }
    None -&gt; should.fail()
  }
  
  // Test black king is at e8
  case get_piece(game, 60) {  // e8 = 60
    Some(piece) -&gt; {
      piece.piece_type
      |&gt; should.equal(types.King)
      piece.color
      |&gt; should.equal(Black)
    }
    None -&gt; should.fail()
  }
}</code></pre>
</div>
</div>

<script>
function toggleFile(id) {
    var content = document.getElementById(id);
    if (content.style.display === 'none') {
        content.style.display = 'block';
        // Highlight the code when first shown
        var codeBlock = content.querySelector('code');
        if (codeBlock && !codeBlock.classList.contains('hljs')) {
            hljs.highlightElement(codeBlock);
        }
    } else {
        content.style.display = 'none';
    }
}
</script>

    </main>
    <footer>
        <p>Generated from benchmark data. All implementations tested via Docker for consistency.</p>
        <p><a href="https://github.com/evaisse/the-great-analysis-challenge">View on GitHub</a></p>
    </footer>
</body>
</html>
