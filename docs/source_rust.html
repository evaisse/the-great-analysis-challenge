<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Source Code - The Great Analysis Challenge</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>üèÜ The Great Analysis Challenge</h1>
        <p class="subtitle">Multi-Language Chess Engine Comparison</p>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/evaisse/the-great-analysis-challenge">GitHub</a>
        </nav>
    </header>
    <main>
<h2>ü¶Ä <a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust</a> Implementation</h2>
<div class="breadcrumb"><a href="index.html">‚Üê Back to Comparison</a></div>
<div class="file-tree">
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Cargo_toml')">üìÑ Cargo.toml</button>
<pre id="Cargo_toml" class="file-content" style="display:none;"><code class="language-toml">[package]
name = "chess-engine"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "chess"
path = "src/main.rs"

[dependencies]</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Dockerfile')">üìÑ Dockerfile</button>
<pre id="Dockerfile" class="file-content" style="display:none;"><code class="language-dockerfile">FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV RUSTUP_HOME=/usr/local/rustup
ENV CARGO_HOME=/usr/local/cargo
ENV PATH=/usr/local/cargo/bin:$PATH

# Install system dependencies and Rust
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    build-essential \
    pkg-config \
    libssl-dev \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install Rust
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
    &amp;&amp; chmod -R a+w $RUSTUP_HOME $CARGO_HOME

WORKDIR /usr/src/chess

COPY . .

RUN cargo build --release

CMD ["./target/release/chess"]</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Makefile')">üìÑ Makefile</button>
<pre id="Makefile" class="file-content" style="display:none;"><code class="language-makefile">.PHONY: all build test analyze clean docker-build docker-test

# Default target - build the chess engine
all: build

# Build target - compile Rust binary
build:
	cargo build --release

# Run basic tests
test:
	cargo test
	@echo "Running basic functionality test..."
	@echo -e "new\nmove e2e4\nmove e7e5\nexport\nquit" | ./target/release/chess | tail -1 | grep -q "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2" &amp;&amp; echo "‚úÖ Basic test passed" || echo "‚ùå Basic test failed"

# Static analysis and code quality
analyze:
	@echo "Running Rust static analysis..."
	cargo fmt --check || true
	cargo clippy -- -D warnings || true
	cargo audit || true

# Clean build artifacts
clean:
	cargo clean

# Docker targets
docker-build:
	docker build -t chess-rust .

docker-test: docker-build
	@echo "Testing Rust implementation in Docker..."
	docker run --rm -i chess-rust sh -c "echo -e 'new\\nmove e2e4\\nmove e7e5\\nexport\\nquit' | ./target/release/chess"

# Help target
help:
	@echo "Available targets:"
	@echo "  make         - Build the chess engine"
	@echo "  make test    - Run tests"
	@echo "  make analyze - Run static analysis"
	@echo "  make clean   - Clean build artifacts"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-test  - Test in Docker"</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('README_md')">üìÑ README.md</button>
<pre id="README_md" class="file-content" style="display:none;"><code class="language-markdown"># Rust Chess Engine

A complete chess engine implementation in Rust following the Chess Engine Specification v1.0.

## Features

- Complete chess rules implementation (castling, en passant, promotion)
- AI opponent with minimax algorithm and alpha-beta pruning
- FEN import/export support
- Performance testing with perft
- Interactive command-line interface
- All standard chess piece movements and special rules
- High performance implementation leveraging Rust's zero-cost abstractions

## Local Development

### Prerequisites
- Rust 1.70+ 
- Cargo

### Setup
```bash
cargo build --release
cargo run --release --bin chess
```

## Docker Usage

### Build the Docker image
```bash
docker build -t chess-engine .
```

### Run interactively
```bash
docker run -it chess-engine
```

### Using Docker Compose
```bash
# Run the chess engine
docker-compose up chess-engine

# Development mode with shell access
docker-compose run chess-dev
```

### Example Docker commands
```bash
# Quick game
echo -e "new\nmove e2e4\nmove e7e5\nai 3\nquit" | docker run -i chess-engine

# Interactive play
docker run -it chess-engine

# Build and run in one command
docker-compose up --build chess-engine
```

## Commands

- `move &lt;from&gt;&lt;to&gt;[promotion]` - Make a move (e.g., e2e4, e7e8Q)
- `undo` - Undo the last move
- `new` - Start a new game  
- `ai &lt;depth&gt;` - Let AI make a move (depth 1-5)
- `fen &lt;string&gt;` - Load position from FEN
- `export` - Export current position as FEN
- `eval` - Evaluate current position
- `perft &lt;depth&gt;` - Run performance test
- `help` - Show available commands
- `quit` - Exit the program

## Architecture

- `src/main.rs` - Main application entry point and command interface
- `src/types.rs` - Type definitions and constants
- `src/board.rs` - Board representation and game state
- `src/move_generator.rs` - Move generation and validation  
- `src/fen.rs` - FEN parsing and serialization
- `src/ai.rs` - AI engine with minimax/alpha-beta
- `src/perft.rs` - Performance testing utilities

## Testing

The engine includes perft testing for move generation verification:
```bash
# In the chess engine
perft 4
```

Expected result: 197281 nodes for perft(4) from starting position.

## Performance

This Rust implementation is optimized for performance with:
- Zero-cost abstractions
- Efficient bit manipulation
- Memory-safe operations
- Fast move generation</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('chess_meta')">üìÑ chess.meta</button>
<pre id="chess_meta" class="file-content" style="display:none;"><code class="language-rust">{
  "language": "rust",
  "version": "1.70",
  "author": "Rust Implementation",
  "build": "cargo build --release",
  "run": "cargo run --release --bin chess",
  "analyze": "cargo clippy -- -D warnings &amp;&amp; cargo fmt --check",
  "test": "cargo test",
  "features": ["perft", "fen", "ai", "castling", "en_passant", "promotion"],
  "max_ai_depth": 5,
  "estimated_perft4_ms": 600
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_ai_rs')">üìÑ src/ai.rs</button>
<pre id="src_ai_rs" class="file-content" style="display:none;"><code class="language-rust">use crate::types::*;
use crate::board::Board;
use crate::move_generator::MoveGenerator;
use std::time::Instant;

pub struct AI {
    move_generator: MoveGenerator,
    nodes_evaluated: u64,
}

#[derive(Debug)]
pub struct SearchResult {
    pub best_move: Option&lt;Move&gt;,
    pub evaluation: i32,
    pub nodes: u64,
    pub time_ms: u128,
}

impl AI {
    pub fn new() -&gt; Self {
        Self {
            move_generator: MoveGenerator::new(),
            nodes_evaluated: 0,
        }
    }

    pub fn find_best_move(&amp;mut self, board: &amp;Board, depth: u8) -&gt; SearchResult {
        let start_time = Instant::now();
        self.nodes_evaluated = 0;
        
        let color = board.get_turn();
        let moves = self.move_generator.get_legal_moves(board, color);
        
        if moves.is_empty() {
            return SearchResult {
                best_move: None,
                evaluation: 0,
                nodes: 0,
                time_ms: 0,
            };
        }

        let mut best_move = moves[0].clone();
        let mut best_eval = if color == Color::White { i32::MIN } else { i32::MAX };

        for chess_move in &amp;moves {
            let mut board_copy = board.get_state().clone();
            let mut test_board = Board::new();
            test_board.set_state(board_copy);
            test_board.make_move(chess_move);
            
            let evaluation = self.minimax(&amp;test_board, depth - 1, i32::MIN, i32::MAX, color == Color::Black);
            
            if (color == Color::White &amp;&amp; evaluation &gt; best_eval) || 
               (color == Color::Black &amp;&amp; evaluation &lt; best_eval) {
                best_eval = evaluation;
                best_move = chess_move.clone();
            }
        }

        let elapsed = start_time.elapsed();
        SearchResult {
            best_move: Some(best_move),
            evaluation: best_eval,
            nodes: self.nodes_evaluated,
            time_ms: elapsed.as_millis(),
        }
    }

    fn minimax(&amp;mut self, board: &amp;Board, depth: u8, alpha: i32, beta: i32, maximizing: bool) -&gt; i32 {
        self.nodes_evaluated += 1;

        if depth == 0 {
            return self.evaluate(board);
        }

        let color = board.get_turn();
        let moves = self.move_generator.get_legal_moves(board, color);

        if moves.is_empty() {
            if self.move_generator.is_in_check(board, color) {
                // Checkmate
                return if maximizing { -100000 } else { 100000 };
            } else {
                // Stalemate
                return 0;
            }
        }

        if maximizing {
            let mut max_eval = i32::MIN;
            let mut current_alpha = alpha;
            
            for chess_move in &amp;moves {
                let mut board_copy = board.get_state().clone();
                let mut test_board = Board::new();
                test_board.set_state(board_copy);
                test_board.make_move(chess_move);
                
                let evaluation = self.minimax(&amp;test_board, depth - 1, current_alpha, beta, false);
                max_eval = max_eval.max(evaluation);
                current_alpha = current_alpha.max(evaluation);
                
                if beta &lt;= current_alpha {
                    break; // Beta cutoff
                }
            }
            
            max_eval
        } else {
            let mut min_eval = i32::MAX;
            let mut current_beta = beta;
            
            for chess_move in &amp;moves {
                let mut board_copy = board.get_state().clone();
                let mut test_board = Board::new();
                test_board.set_state(board_copy);
                test_board.make_move(chess_move);
                
                let evaluation = self.minimax(&amp;test_board, depth - 1, alpha, current_beta, true);
                min_eval = min_eval.min(evaluation);
                current_beta = current_beta.min(evaluation);
                
                if current_beta &lt;= alpha {
                    break; // Alpha cutoff
                }
            }
            
            min_eval
        }
    }

    fn evaluate(&amp;self, board: &amp;Board) -&gt; i32 {
        let mut score = 0;

        for square in 0..64 {
            if let Some(piece) = board.get_piece(square) {
                let value = piece.piece_type.value();
                let position_bonus = self.get_position_bonus(square, piece.piece_type, piece.color, board);
                let total_value = value + position_bonus;
                
                score += if piece.color == Color::White { total_value } else { -total_value };
            }
        }

        score
    }

    fn get_position_bonus(&amp;self, square: Square, piece_type: PieceType, color: Color, board: &amp;Board) -&gt; i32 {
        let file = square % 8;
        let rank = square / 8;
        let mut bonus = 0;

        // Center control bonus
        let center_squares = [27, 28, 35, 36]; // d4, e4, d5, e5
        if center_squares.contains(&amp;square) {
            bonus += 10;
        }

        match piece_type {
            PieceType::Pawn =&gt; {
                // Pawn advancement bonus
                let advancement = if color == Color::White { rank } else { 7 - rank };
                bonus += (advancement * 5) as i32;
            },
            PieceType::King =&gt; {
                // King safety in opening/middlegame
                if !self.is_endgame(board) {
                    let safe_rank = if color == Color::White { 0 } else { 7 };
                    if rank == safe_rank &amp;&amp; (file &lt;= 2 || file &gt;= 5) {
                        bonus += 20;
                    } else {
                        bonus -= 20;
                    }
                }
            },
            _ =&gt; {}
        }

        bonus
    }

    fn is_endgame(&amp;self, board: &amp;Board) -&gt; bool {
        let mut piece_count = 0;
        let mut queen_count = 0;
        
        for square in 0..64 {
            if let Some(piece) = board.get_piece(square) {
                if piece.piece_type != PieceType::King &amp;&amp; piece.piece_type != PieceType::Pawn {
                    piece_count += 1;
                    if piece.piece_type == PieceType::Queen {
                        queen_count += 1;
                    }
                }
            }
        }
        
        piece_count &lt;= 4 || (piece_count &lt;= 6 &amp;&amp; queen_count == 0)
    }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_board_rs')">üìÑ src/board.rs</button>
<pre id="src_board_rs" class="file-content" style="display:none;"><code class="language-rust">use crate::types::*;
use std::fmt;

pub struct Board {
    state: GameState,
}

impl Board {
    pub fn new() -&gt; Self {
        Self {
            state: GameState::new(),
        }
    }

    pub fn reset(&amp;mut self) {
        self.state = GameState::new();
    }

    pub fn get_piece(&amp;self, square: Square) -&gt; Option&lt;Piece&gt; {
        self.state.board[square]
    }

    pub fn set_piece(&amp;mut self, square: Square, piece: Option&lt;Piece&gt;) {
        self.state.board[square] = piece;
    }

    pub fn get_turn(&amp;self) -&gt; Color {
        self.state.turn
    }

    pub fn set_turn(&amp;mut self, color: Color) {
        self.state.turn = color;
    }

    pub fn get_castling_rights(&amp;self) -&gt; CastlingRights {
        self.state.castling_rights
    }

    pub fn set_castling_rights(&amp;mut self, rights: CastlingRights) {
        self.state.castling_rights = rights;
    }

    pub fn get_en_passant_target(&amp;self) -&gt; Option&lt;Square&gt; {
        self.state.en_passant_target
    }

    pub fn set_en_passant_target(&amp;mut self, square: Option&lt;Square&gt;) {
        self.state.en_passant_target = square;
    }

    pub fn get_state(&amp;self) -&gt; &amp;GameState {
        &amp;self.state
    }

    pub fn set_state(&amp;mut self, state: GameState) {
        self.state = state;
    }

    pub fn make_move(&amp;mut self, chess_move: &amp;Move) {
        let piece = self.get_piece(chess_move.from);
        if piece.is_none() {
            return;
        }
        let piece = piece.unwrap();

        // Move piece
        self.set_piece(chess_move.to, Some(piece));
        self.set_piece(chess_move.from, None);

        // Handle castling
        if chess_move.is_castling {
            let rank = if piece.color == Color::White { 0 } else { 7 };
            let (rook_from, rook_to) = if chess_move.to == rank * 8 + 6 {
                // Kingside
                (rank * 8 + 7, rank * 8 + 5)
            } else {
                // Queenside
                (rank * 8, rank * 8 + 3)
            };

            if let Some(rook) = self.get_piece(rook_from) {
                self.set_piece(rook_to, Some(rook));
                self.set_piece(rook_from, None);
            }
        }

        // Handle en passant
        if chess_move.is_en_passant {
            let captured_pawn_square = if piece.color == Color::White {
                chess_move.to - 8
            } else {
                chess_move.to + 8
            };
            self.set_piece(captured_pawn_square, None);
        }

        // Handle promotion
        if let Some(promotion) = chess_move.promotion {
            self.set_piece(chess_move.to, Some(Piece::new(promotion, piece.color)));
        }

        // Update castling rights
        let mut rights = self.get_castling_rights();
        if piece.piece_type == PieceType::King {
            if piece.color == Color::White {
                rights.white_kingside = false;
                rights.white_queenside = false;
            } else {
                rights.black_kingside = false;
                rights.black_queenside = false;
            }
        } else if piece.piece_type == PieceType::Rook {
            match (piece.color, chess_move.from) {
                (Color::White, 0) =&gt; rights.white_queenside = false,
                (Color::White, 7) =&gt; rights.white_kingside = false,
                (Color::Black, 56) =&gt; rights.black_queenside = false,
                (Color::Black, 63) =&gt; rights.black_kingside = false,
                _ =&gt; {}
            }
        }
        self.set_castling_rights(rights);

        // Update en passant target
        if piece.piece_type == PieceType::Pawn &amp;&amp; 
           (chess_move.to as i32 - chess_move.from as i32).abs() == 16 {
            let en_passant_square = (chess_move.from + chess_move.to) / 2;
            self.set_en_passant_target(Some(en_passant_square));
        } else {
            self.set_en_passant_target(None);
        }

        // Update halfmove clock
        if piece.piece_type == PieceType::Pawn || chess_move.captured.is_some() {
            self.state.halfmove_clock = 0;
        } else {
            self.state.halfmove_clock += 1;
        }

        // Update fullmove number
        if piece.color == Color::Black {
            self.state.fullmove_number += 1;
        }

        // Switch turn
        self.state.turn = piece.color.opposite();
        self.state.move_history.push(chess_move.clone());
    }

    pub fn undo_move(&amp;mut self) -&gt; Option&lt;Move&gt; {
        let chess_move = self.state.move_history.pop()?;
        
        // Get the piece that was moved
        let moved_piece = self.get_piece(chess_move.to)?;
        
        // Restore the original piece (handle promotion)
        let original_piece = if chess_move.promotion.is_some() {
            Piece::new(PieceType::Pawn, moved_piece.color)
        } else {
            moved_piece
        };
        
        // Move piece back
        self.set_piece(chess_move.from, Some(original_piece));
        
        // Restore captured piece or clear destination
        if let Some(captured) = chess_move.captured {
            let captured_color = moved_piece.color.opposite();
            self.set_piece(chess_move.to, Some(Piece::new(captured, captured_color)));
        } else {
            self.set_piece(chess_move.to, None);
        }

        // Handle castling
        if chess_move.is_castling {
            let rank = if moved_piece.color == Color::White { 0 } else { 7 };
            let (rook_from, rook_to) = if chess_move.to == rank * 8 + 6 {
                // Kingside
                (rank * 8 + 5, rank * 8 + 7)
            } else {
                // Queenside  
                (rank * 8 + 3, rank * 8)
            };

            if let Some(rook) = self.get_piece(rook_from) {
                self.set_piece(rook_to, Some(rook));
                self.set_piece(rook_from, None);
            }
        }

        // Handle en passant
        if chess_move.is_en_passant {
            let captured_pawn_square = if moved_piece.color == Color::White {
                chess_move.to - 8
            } else {
                chess_move.to + 8
            };
            let captured_color = moved_piece.color.opposite();
            self.set_piece(captured_pawn_square, Some(Piece::new(PieceType::Pawn, captured_color)));
        }

        // Restore turn
        self.state.turn = moved_piece.color;

        Some(chess_move)
    }
}

impl fmt::Display for Board {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        writeln!(f, "  a b c d e f g h")?;
        
        for rank in (0..8).rev() {
            write!(f, "{} ", rank + 1)?;
            for file in 0..8 {
                let square = rank * 8 + file;
                match self.get_piece(square) {
                    Some(piece) =&gt; write!(f, "{} ", piece.to_char())?,
                    None =&gt; write!(f, ". ")?,
                }
            }
            writeln!(f, "{}", rank + 1)?;
        }
        
        writeln!(f, "  a b c d e f g h")?;
        writeln!(f)?;
        write!(f, "{} to move", 
            if self.get_turn() == Color::White { "White" } else { "Black" })
    }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_fen_rs')">üìÑ src/fen.rs</button>
<pre id="src_fen_rs" class="file-content" style="display:none;"><code class="language-rust">use crate::types::*;
use crate::board::Board;

pub struct FenParser;

impl FenParser {
    pub fn new() -&gt; Self {
        Self
    }

    pub fn parse_fen(&amp;self, board: &amp;mut Board, fen: &amp;str) -&gt; Result&lt;(), String&gt; {
        let parts: Vec&lt;&amp;str&gt; = fen.split_whitespace().collect();
        if parts.len() &lt; 4 {
            return Err("ERROR: Invalid FEN string".to_string());
        }

        let pieces = parts[0];
        let turn = parts[1];
        let castling = parts[2];
        let en_passant = parts[3];
        let halfmove = parts.get(4).unwrap_or(&amp;"0");
        let fullmove = parts.get(5).unwrap_or(&amp;"1");

        // Clear board
        for i in 0..64 {
            board.set_piece(i, None);
        }

        // Parse piece positions
        let mut square = 56; // Start at a8 (top-left)
        for ch in pieces.chars() {
            match ch {
                '/' =&gt; square -= 16, // Move to next rank
                '1'..='8' =&gt; {
                    let empty_squares = ch.to_digit(10).unwrap() as usize;
                    square += empty_squares;
                },
                _ =&gt; {
                    if let Some(piece) = Piece::from_char(ch) {
                        board.set_piece(square, Some(piece));
                        square += 1;
                    }
                }
            }
        }

        // Parse turn
        let color = match turn {
            "w" =&gt; Color::White,
            "b" =&gt; Color::Black,
            _ =&gt; return Err("ERROR: Invalid FEN string".to_string()),
        };
        board.set_turn(color);

        // Parse castling rights
        let mut rights = CastlingRights::none();
        if castling.contains('K') { rights.white_kingside = true; }
        if castling.contains('Q') { rights.white_queenside = true; }
        if castling.contains('k') { rights.black_kingside = true; }
        if castling.contains('q') { rights.black_queenside = true; }
        board.set_castling_rights(rights);

        // Parse en passant target
        if en_passant != "-" {
            if let Ok(square) = algebraic_to_square(en_passant) {
                board.set_en_passant_target(Some(square));
            }
        } else {
            board.set_en_passant_target(None);
        }

        // Parse move counters
        let state = board.get_state();
        let mut new_state = state.clone();
        new_state.halfmove_clock = halfmove.parse().unwrap_or(0);
        new_state.fullmove_number = fullmove.parse().unwrap_or(1);
        board.set_state(new_state);

        Ok(())
    }

    pub fn export_fen(&amp;self, board: &amp;Board) -&gt; String {
        let pieces = self.get_pieces_string(board);
        let turn = if board.get_turn() == Color::White { "w" } else { "b" };
        let castling = self.get_castling_string(board);
        let en_passant = self.get_en_passant_string(board);
        let state = board.get_state();
        
        format!("{} {} {} {} {} {}", 
            pieces, turn, castling, en_passant, 
            state.halfmove_clock, state.fullmove_number)
    }

    fn get_pieces_string(&amp;self, board: &amp;Board) -&gt; String {
        let mut result = String::new();
        
        for rank in (0..8).rev() {
            let mut empty_count = 0;
            
            for file in 0..8 {
                let square = rank * 8 + file;
                
                if let Some(piece) = board.get_piece(square) {
                    if empty_count &gt; 0 {
                        result.push_str(&amp;empty_count.to_string());
                        empty_count = 0;
                    }
                    result.push(piece.to_char());
                } else {
                    empty_count += 1;
                }
            }
            
            if empty_count &gt; 0 {
                result.push_str(&amp;empty_count.to_string());
            }
            
            if rank &gt; 0 {
                result.push('/');
            }
        }
        
        result
    }

    fn get_castling_string(&amp;self, board: &amp;Board) -&gt; String {
        let rights = board.get_castling_rights();
        let mut result = String::new();
        
        if rights.white_kingside { result.push('K'); }
        if rights.white_queenside { result.push('Q'); }
        if rights.black_kingside { result.push('k'); }
        if rights.black_queenside { result.push('q'); }
        
        if result.is_empty() {
            result.push('-');
        }
        
        result
    }

    fn get_en_passant_string(&amp;self, board: &amp;Board) -&gt; String {
        match board.get_en_passant_target() {
            Some(square) =&gt; square_to_algebraic(square),
            None =&gt; "-".to_string(),
        }
    }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_main_rs')">üìÑ src/main.rs</button>
<pre id="src_main_rs" class="file-content" style="display:none;"><code class="language-rust">mod types;
mod board;
mod move_generator;
mod fen;
mod ai;
mod perft;

use crate::board::Board;
use crate::move_generator::MoveGenerator;
use crate::fen::FenParser;
use crate::ai::AI;
use crate::perft::Perft;
use crate::types::*;
use std::io::{self, Write};
use std::time::Instant;

struct ChessEngine {
    board: Board,
    move_generator: MoveGenerator,
    fen_parser: FenParser,
    ai: AI,
    perft: Perft,
}

impl ChessEngine {
    fn new() -&gt; Self {
        Self {
            board: Board::new(),
            move_generator: MoveGenerator::new(),
            fen_parser: FenParser::new(),
            ai: AI::new(),
            perft: Perft::new(),
        }
    }

    fn run(&amp;mut self) {
        println!("{}", self.board);
        
        loop {
            print!("");
            io::stdout().flush().unwrap();
            
            let mut input = String::new();
            if io::stdin().read_line(&amp;mut input).is_err() {
                break;
            }
            
            let command = input.trim();
            if command.is_empty() {
                continue;
            }
            
            if !self.process_command(command) {
                break;
            }
        }
    }

    fn process_command(&amp;mut self, command: &amp;str) -&gt; bool {
        let parts: Vec&lt;&amp;str&gt; = command.split_whitespace().collect();
        if parts.is_empty() {
            return true;
        }

        match parts[0].to_lowercase().as_str() {
            "move" =&gt; {
                if parts.len() &gt; 1 {
                    self.handle_move(parts[1]);
                } else {
                    println!("ERROR: Invalid move format");
                }
            },
            "undo" =&gt; self.handle_undo(),
            "new" =&gt; self.handle_new(),
            "ai" =&gt; {
                if parts.len() &gt; 1 {
                    self.handle_ai(parts[1]);
                } else {
                    println!("ERROR: AI depth must be 1-5");
                }
            },
            "fen" =&gt; {
                if parts.len() &gt; 1 {
                    let fen_string = parts[1..].join(" ");
                    self.handle_fen(&amp;fen_string);
                } else {
                    println!("ERROR: Invalid FEN string");
                }
            },
            "export" =&gt; self.handle_export(),
            "eval" =&gt; self.handle_eval(),
            "perft" =&gt; {
                if parts.len() &gt; 1 {
                    self.handle_perft(parts[1]);
                } else {
                    println!("ERROR: Invalid perft depth");
                }
            },
            "help" =&gt; self.handle_help(),
            "quit" =&gt; return false,
            _ =&gt; println!("ERROR: Invalid command"),
        }

        true
    }

    fn handle_move(&amp;mut self, move_str: &amp;str) {
        if move_str.len() &lt; 4 {
            println!("ERROR: Invalid move format");
            return;
        }

        let from_str = &amp;move_str[0..2];
        let to_str = &amp;move_str[2..4];
        let promotion_str = if move_str.len() &gt; 4 { 
            Some(&amp;move_str[4..5]) 
        } else { 
            None 
        };

        let from_square = match algebraic_to_square(from_str) {
            Ok(square) =&gt; square,
            Err(_) =&gt; {
                println!("ERROR: Invalid move format");
                return;
            }
        };

        let to_square = match algebraic_to_square(to_str) {
            Ok(square) =&gt; square,
            Err(_) =&gt; {
                println!("ERROR: Invalid move format");
                return;
            }
        };

        let piece = match self.board.get_piece(from_square) {
            Some(p) =&gt; p,
            None =&gt; {
                println!("ERROR: No piece at source square");
                return;
            }
        };

        if piece.color != self.board.get_turn() {
            println!("ERROR: Wrong color piece");
            return;
        }

        let legal_moves = self.move_generator.get_legal_moves(&amp;self.board, self.board.get_turn());
        let mut matching_move = None;

        for chess_move in &amp;legal_moves {
            if chess_move.from == from_square &amp;&amp; chess_move.to == to_square {
                if let Some(promotion) = chess_move.promotion {
                    if let Some(promo_str) = promotion_str {
                        if let Some(promo_type) = PieceType::from_char(promo_str.chars().next().unwrap_or(' ')) {
                            if promotion == promo_type {
                                matching_move = Some(chess_move.clone());
                                break;
                            }
                        }
                    } else if promotion == PieceType::Queen {
                        // Default to queen if no promotion specified
                        matching_move = Some(chess_move.clone());
                        break;
                    }
                } else {
                    matching_move = Some(chess_move.clone());
                    break;
                }
            }
        }

        match matching_move {
            Some(chess_move) =&gt; {
                self.board.make_move(&amp;chess_move);
                println!("OK: {}", move_str);
                println!("{}", self.board);
                self.check_game_end();
            },
            None =&gt; {
                if self.move_generator.is_in_check(&amp;self.board, self.board.get_turn()) {
                    println!("ERROR: King would be in check");
                } else {
                    println!("ERROR: Illegal move");
                }
            }
        }
    }

    fn handle_undo(&amp;mut self) {
        match self.board.undo_move() {
            Some(_) =&gt; {
                println!("Move undone");
                println!("{}", self.board);
            },
            None =&gt; println!("ERROR: No moves to undo"),
        }
    }

    fn handle_new(&amp;mut self) {
        self.board.reset();
        println!("New game started");
        println!("{}", self.board);
    }

    fn handle_ai(&amp;mut self, depth_str: &amp;str) {
        let depth = match depth_str.parse::&lt;u8&gt;() {
            Ok(d) if d &gt;= 1 &amp;&amp; d &lt;= 5 =&gt; d,
            _ =&gt; {
                println!("ERROR: AI depth must be 1-5");
                return;
            }
        };

        let result = self.ai.find_best_move(&amp;self.board, depth);
        
        match result.best_move {
            Some(chess_move) =&gt; {
                let move_str = format!("{}{}{}", 
                    square_to_algebraic(chess_move.from),
                    square_to_algebraic(chess_move.to),
                    chess_move.promotion.map_or(String::new(), |p| p.to_string())
                );
                
                self.board.make_move(&amp;chess_move);
                println!("AI: {} (depth={}, eval={}, time={}ms)", 
                    move_str, depth, result.evaluation, result.time_ms);
                println!("{}", self.board);
                self.check_game_end();
            },
            None =&gt; println!("ERROR: No legal moves available"),
        }
    }

    fn handle_fen(&amp;mut self, fen_string: &amp;str) {
        match self.fen_parser.parse_fen(&amp;mut self.board, fen_string) {
            Ok(_) =&gt; {
                println!("Position loaded from FEN");
                println!("{}", self.board);
            },
            Err(err) =&gt; println!("{}", err),
        }
    }

    fn handle_export(&amp;self) {
        let fen = self.fen_parser.export_fen(&amp;self.board);
        println!("FEN: {}", fen);
    }

    fn handle_eval(&amp;self) {
        let mut ai_copy = AI::new();
        let evaluation = ai_copy.find_best_move(&amp;self.board, 1).evaluation;
        println!("Position evaluation: {}", evaluation);
    }

    fn handle_perft(&amp;self, depth_str: &amp;str) {
        let depth = match depth_str.parse::&lt;u8&gt;() {
            Ok(d) if d &gt;= 1 =&gt; d,
            _ =&gt; {
                println!("ERROR: Invalid perft depth");
                return;
            }
        };

        let start_time = Instant::now();
        let nodes = self.perft.perft(&amp;self.board, depth);
        let elapsed = start_time.elapsed();
        
        println!("Perft({}): {} nodes ({}ms)", depth, nodes, elapsed.as_millis());
    }

    fn handle_help(&amp;self) {
        println!("Available commands:");
        println!("  move &lt;from&gt;&lt;to&gt;[promotion] - Make a move (e.g., e2e4, e7e8Q)");
        println!("  undo - Undo the last move");
        println!("  new - Start a new game");
        println!("  ai &lt;depth&gt; - Let AI make a move (depth 1-5)");
        println!("  fen &lt;string&gt; - Load position from FEN");
        println!("  export - Export current position as FEN");
        println!("  eval - Evaluate current position");
        println!("  perft &lt;depth&gt; - Run performance test");
        println!("  help - Show this help message");
        println!("  quit - Exit the program");
    }

    fn check_game_end(&amp;self) {
        let color = self.board.get_turn();
        let legal_moves = self.move_generator.get_legal_moves(&amp;self.board, color);
        
        if legal_moves.is_empty() {
            if self.move_generator.is_in_check(&amp;self.board, color) {
                let winner = if color == Color::White { "Black" } else { "White" };
                println!("CHECKMATE: {} wins", winner);
            } else {
                println!("STALEMATE: Draw");
            }
        }
    }
}

fn main() {
    let mut engine = ChessEngine::new();
    engine.run();
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_move_generator_rs')">üìÑ src/move_generator.rs</button>
<pre id="src_move_generator_rs" class="file-content" style="display:none;"><code class="language-rust">use crate::types::*;
use crate::board::Board;

pub struct MoveGenerator;

impl MoveGenerator {
    pub fn new() -&gt; Self {
        Self
    }

    pub fn generate_moves(&amp;self, board: &amp;Board, color: Color) -&gt; Vec&lt;Move&gt; {
        let mut moves = Vec::new();
        
        for square in 0..64 {
            if let Some(piece) = board.get_piece(square) {
                if piece.color == color {
                    moves.extend(self.generate_piece_moves(board, square, piece));
                }
            }
        }
        
        moves
    }

    fn generate_piece_moves(&amp;self, board: &amp;Board, from: Square, piece: Piece) -&gt; Vec&lt;Move&gt; {
        match piece.piece_type {
            PieceType::Pawn =&gt; self.generate_pawn_moves(board, from, piece.color),
            PieceType::Knight =&gt; self.generate_knight_moves(board, from, piece.color),
            PieceType::Bishop =&gt; self.generate_bishop_moves(board, from, piece.color),
            PieceType::Rook =&gt; self.generate_rook_moves(board, from, piece.color),
            PieceType::Queen =&gt; self.generate_queen_moves(board, from, piece.color),
            PieceType::King =&gt; self.generate_king_moves(board, from, piece.color),
        }
    }

    fn generate_pawn_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        let mut moves = Vec::new();
        let direction = if color == Color::White { 8 } else { -8i32 } as i32;
        let start_rank = if color == Color::White { 1 } else { 6 };
        let promotion_rank = if color == Color::White { 7 } else { 0 };
        
        let from_i32 = from as i32;
        let rank = from / 8;
        let file = from % 8;

        // One square forward
        let one_forward = from_i32 + direction;
        if self.is_valid_square(one_forward) &amp;&amp; board.get_piece(one_forward as usize).is_none() {
            let to = one_forward as usize;
            if to / 8 == promotion_rank {
                // Promotion moves
                for promotion_piece in [PieceType::Queen, PieceType::Rook, PieceType::Bishop, PieceType::Knight] {
                    moves.push(Move::new(from, to, PieceType::Pawn).with_promotion(promotion_piece));
                }
            } else {
                moves.push(Move::new(from, to, PieceType::Pawn));
            }

            // Two squares forward from starting position
            if rank == start_rank {
                let two_forward = from_i32 + 2 * direction;
                if self.is_valid_square(two_forward) &amp;&amp; board.get_piece(two_forward as usize).is_none() {
                    moves.push(Move::new(from, two_forward as usize, PieceType::Pawn));
                }
            }
        }

        // Captures
        for &amp;offset in &amp;[direction - 1, direction + 1] {
            let to = from_i32 + offset;
            let to_file = (to % 8) as usize;
            
            if self.is_valid_square(to) &amp;&amp; (to_file as i32 - file as i32).abs() == 1 {
                let to_square = to as usize;
                if let Some(target_piece) = board.get_piece(to_square) {
                    if target_piece.color != color {
                        if to_square / 8 == promotion_rank {
                            // Promotion captures
                            for promotion_piece in [PieceType::Queen, PieceType::Rook, PieceType::Bishop, PieceType::Knight] {
                                moves.push(Move::new(from, to_square, PieceType::Pawn)
                                    .with_capture(target_piece.piece_type)
                                    .with_promotion(promotion_piece));
                            }
                        } else {
                            moves.push(Move::new(from, to_square, PieceType::Pawn)
                                .with_capture(target_piece.piece_type));
                        }
                    }
                }
            }
        }

        // En passant
        if let Some(en_passant_target) = board.get_en_passant_target() {
            let expected_rank = if color == Color::White { 4 } else { 3 };
            if rank == expected_rank {
                for &amp;offset in &amp;[direction - 1, direction + 1] {
                    let to = from_i32 + offset;
                    if self.is_valid_square(to) &amp;&amp; to as usize == en_passant_target {
                        moves.push(Move::new(from, to as usize, PieceType::Pawn)
                            .with_capture(PieceType::Pawn)
                            .with_en_passant());
                    }
                }
            }
        }

        moves
    }

    fn generate_knight_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        let mut moves = Vec::new();
        let offsets = [-17, -15, -10, -6, 6, 10, 15, 17];
        let from_i32 = from as i32;
        let file = from % 8;

        for offset in offsets {
            let to = from_i32 + offset;
            let to_file = (to % 8) as usize;

            if self.is_valid_square(to) &amp;&amp; (to_file as i32 - file as i32).abs() &lt;= 2 {
                let to_square = to as usize;
                match board.get_piece(to_square) {
                    None =&gt; moves.push(Move::new(from, to_square, PieceType::Knight)),
                    Some(piece) if piece.color != color =&gt; {
                        moves.push(Move::new(from, to_square, PieceType::Knight)
                            .with_capture(piece.piece_type));
                    },
                    _ =&gt; {}
                }
            }
        }

        moves
    }

    fn generate_bishop_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        self.generate_sliding_moves(board, from, color, &amp;[-9, -7, 7, 9], PieceType::Bishop)
    }

    fn generate_rook_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        self.generate_sliding_moves(board, from, color, &amp;[-8, -1, 1, 8], PieceType::Rook)
    }

    fn generate_queen_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        self.generate_sliding_moves(board, from, color, &amp;[-9, -8, -7, -1, 1, 7, 8, 9], PieceType::Queen)
    }

    fn generate_king_moves(&amp;self, board: &amp;Board, from: Square, color: Color) -&gt; Vec&lt;Move&gt; {
        let mut moves = Vec::new();
        let offsets = [-9, -8, -7, -1, 1, 7, 8, 9];
        let from_i32 = from as i32;
        let file = from % 8;

        for offset in offsets {
            let to = from_i32 + offset;
            let to_file = (to % 8) as usize;

            if self.is_valid_square(to) &amp;&amp; (to_file as i32 - file as i32).abs() &lt;= 1 {
                let to_square = to as usize;
                match board.get_piece(to_square) {
                    None =&gt; moves.push(Move::new(from, to_square, PieceType::King)),
                    Some(piece) if piece.color != color =&gt; {
                        moves.push(Move::new(from, to_square, PieceType::King)
                            .with_capture(piece.piece_type));
                    },
                    _ =&gt; {}
                }
            }
        }

        // Castling
        let rights = board.get_castling_rights();
        if color == Color::White &amp;&amp; from == 4 {
            // White kingside
            if rights.white_kingside &amp;&amp; 
               board.get_piece(5).is_none() &amp;&amp; 
               board.get_piece(6).is_none() &amp;&amp;
               board.get_piece(7).map_or(false, |p| p.piece_type == PieceType::Rook &amp;&amp; p.color == Color::White) {
                if !self.is_square_attacked(board, 4, Color::Black) &amp;&amp;
                   !self.is_square_attacked(board, 5, Color::Black) &amp;&amp;
                   !self.is_square_attacked(board, 6, Color::Black) {
                    moves.push(Move::new(4, 6, PieceType::King).with_castling());
                }
            }
            // White queenside
            if rights.white_queenside &amp;&amp;
               board.get_piece(3).is_none() &amp;&amp;
               board.get_piece(2).is_none() &amp;&amp;
               board.get_piece(1).is_none() &amp;&amp;
               board.get_piece(0).map_or(false, |p| p.piece_type == PieceType::Rook &amp;&amp; p.color == Color::White) {
                if !self.is_square_attacked(board, 4, Color::Black) &amp;&amp;
                   !self.is_square_attacked(board, 3, Color::Black) &amp;&amp;
                   !self.is_square_attacked(board, 2, Color::Black) {
                    moves.push(Move::new(4, 2, PieceType::King).with_castling());
                }
            }
        } else if color == Color::Black &amp;&amp; from == 60 {
            // Black kingside
            if rights.black_kingside &amp;&amp;
               board.get_piece(61).is_none() &amp;&amp;
               board.get_piece(62).is_none() &amp;&amp;
               board.get_piece(63).map_or(false, |p| p.piece_type == PieceType::Rook &amp;&amp; p.color == Color::Black) {
                if !self.is_square_attacked(board, 60, Color::White) &amp;&amp;
                   !self.is_square_attacked(board, 61, Color::White) &amp;&amp;
                   !self.is_square_attacked(board, 62, Color::White) {
                    moves.push(Move::new(60, 62, PieceType::King).with_castling());
                }
            }
            // Black queenside
            if rights.black_queenside &amp;&amp;
               board.get_piece(59).is_none() &amp;&amp;
               board.get_piece(58).is_none() &amp;&amp;
               board.get_piece(57).is_none() &amp;&amp;
               board.get_piece(56).map_or(false, |p| p.piece_type == PieceType::Rook &amp;&amp; p.color == Color::Black) {
                if !self.is_square_attacked(board, 60, Color::White) &amp;&amp;
                   !self.is_square_attacked(board, 59, Color::White) &amp;&amp;
                   !self.is_square_attacked(board, 58, Color::White) {
                    moves.push(Move::new(60, 58, PieceType::King).with_castling());
                }
            }
        }

        moves
    }

    fn generate_sliding_moves(&amp;self, board: &amp;Board, from: Square, color: Color, directions: &amp;[i32], piece_type: PieceType) -&gt; Vec&lt;Move&gt; {
        let mut moves = Vec::new();
        let from_i32 = from as i32;

        for &amp;direction in directions {
            let mut to = from_i32 + direction;
            let mut prev_file = (from % 8) as i32;

            while self.is_valid_square(to) {
                let to_file = to % 8;
                
                // Check for wrapping (especially important for horizontal moves)
                if direction == -1 || direction == 1 {
                    if (to_file - prev_file).abs() != 1 {
                        break;
                    }
                }

                let to_square = to as usize;
                match board.get_piece(to_square) {
                    None =&gt; {
                        moves.push(Move::new(from, to_square, piece_type));
                    },
                    Some(piece) =&gt; {
                        if piece.color != color {
                            moves.push(Move::new(from, to_square, piece_type)
                                .with_capture(piece.piece_type));
                        }
                        break;
                    }
                }

                prev_file = to_file;
                to += direction;
            }
        }

        moves
    }

    pub fn is_square_attacked(&amp;self, board: &amp;Board, square: Square, by_color: Color) -&gt; bool {
        for from in 0..64 {
            if let Some(piece) = board.get_piece(from) {
                if piece.color == by_color {
                    let moves = self.generate_piece_moves(board, from, piece);
                    if moves.iter().any(|m| m.to == square) {
                        return true;
                    }
                }
            }
        }
        false
    }

    pub fn is_in_check(&amp;self, board: &amp;Board, color: Color) -&gt; bool {
        for square in 0..64 {
            if let Some(piece) = board.get_piece(square) {
                if piece.color == color &amp;&amp; piece.piece_type == PieceType::King {
                    return self.is_square_attacked(board, square, color.opposite());
                }
            }
        }
        false
    }

    pub fn get_legal_moves(&amp;self, board: &amp;Board, color: Color) -&gt; Vec&lt;Move&gt; {
        let moves = self.generate_moves(board, color);
        let mut legal_moves = Vec::new();

        for chess_move in moves {
            let mut board_copy = board.get_state().clone();
            let mut test_board = Board::new();
            test_board.set_state(board_copy);
            
            test_board.make_move(&amp;chess_move);
            
            if !self.is_in_check(&amp;test_board, color) {
                legal_moves.push(chess_move);
            }
        }

        legal_moves
    }

    pub fn is_checkmate(&amp;self, board: &amp;Board, color: Color) -&gt; bool {
        self.is_in_check(board, color) &amp;&amp; self.get_legal_moves(board, color).is_empty()
    }

    pub fn is_stalemate(&amp;self, board: &amp;Board, color: Color) -&gt; bool {
        !self.is_in_check(board, color) &amp;&amp; self.get_legal_moves(board, color).is_empty()
    }

    fn is_valid_square(&amp;self, square: i32) -&gt; bool {
        square &gt;= 0 &amp;&amp; square &lt; 64
    }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_perft_rs')">üìÑ src/perft.rs</button>
<pre id="src_perft_rs" class="file-content" style="display:none;"><code class="language-rust">use crate::types::*;
use crate::board::Board;
use crate::move_generator::MoveGenerator;
use std::collections::HashMap;

pub struct Perft {
    move_generator: MoveGenerator,
}

impl Perft {
    pub fn new() -&gt; Self {
        Self {
            move_generator: MoveGenerator::new(),
        }
    }

    pub fn perft(&amp;self, board: &amp;Board, depth: u8) -&gt; u64 {
        if depth == 0 {
            return 1;
        }

        let color = board.get_turn();
        let moves = self.move_generator.get_legal_moves(board, color);
        let mut nodes = 0;

        for chess_move in &amp;moves {
            let mut board_copy = board.get_state().clone();
            let mut test_board = Board::new();
            test_board.set_state(board_copy);
            test_board.make_move(chess_move);
            
            nodes += self.perft(&amp;test_board, depth - 1);
        }

        nodes
    }

    pub fn perft_divide(&amp;self, board: &amp;Board, depth: u8) -&gt; HashMap&lt;String, u64&gt; {
        let mut results = HashMap::new();
        let color = board.get_turn();
        let moves = self.move_generator.get_legal_moves(board, color);

        for chess_move in &amp;moves {
            let from = square_to_algebraic(chess_move.from);
            let to = square_to_algebraic(chess_move.to);
            let move_str = match chess_move.promotion {
                Some(promotion) =&gt; format!("{}{}{}", from, to, promotion),
                None =&gt; format!("{}{}", from, to),
            };
            
            let mut board_copy = board.get_state().clone();
            let mut test_board = Board::new();
            test_board.set_state(board_copy);
            test_board.make_move(chess_move);
            
            let count = self.perft(&amp;test_board, depth - 1);
            results.insert(move_str, count);
        }

        results
    }
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('src_types_rs')">üìÑ src/types.rs</button>
<pre id="src_types_rs" class="file-content" style="display:none;"><code class="language-rust">use std::fmt;

pub type Square = usize;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PieceType {
    King,
    Queen,
    Rook,
    Bishop,
    Knight,
    Pawn,
}

impl fmt::Display for PieceType {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let ch = match self {
            PieceType::King =&gt; 'K',
            PieceType::Queen =&gt; 'Q',
            PieceType::Rook =&gt; 'R',
            PieceType::Bishop =&gt; 'B',
            PieceType::Knight =&gt; 'N',
            PieceType::Pawn =&gt; 'P',
        };
        write!(f, "{}", ch)
    }
}

impl PieceType {
    pub fn from_char(ch: char) -&gt; Option&lt;PieceType&gt; {
        match ch.to_ascii_uppercase() {
            'K' =&gt; Some(PieceType::King),
            'Q' =&gt; Some(PieceType::Queen),
            'R' =&gt; Some(PieceType::Rook),
            'B' =&gt; Some(PieceType::Bishop),
            'N' =&gt; Some(PieceType::Knight),
            'P' =&gt; Some(PieceType::Pawn),
            _ =&gt; None,
        }
    }

    pub fn value(&amp;self) -&gt; i32 {
        match self {
            PieceType::Pawn =&gt; 100,
            PieceType::Knight =&gt; 320,
            PieceType::Bishop =&gt; 330,
            PieceType::Rook =&gt; 500,
            PieceType::Queen =&gt; 900,
            PieceType::King =&gt; 20000,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Color {
    White,
    Black,
}

impl Color {
    pub fn opposite(&amp;self) -&gt; Color {
        match self {
            Color::White =&gt; Color::Black,
            Color::Black =&gt; Color::White,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Piece {
    pub piece_type: PieceType,
    pub color: Color,
}

impl Piece {
    pub fn new(piece_type: PieceType, color: Color) -&gt; Self {
        Self { piece_type, color }
    }

    pub fn to_char(&amp;self) -&gt; char {
        let ch = match self.piece_type {
            PieceType::King =&gt; 'K',
            PieceType::Queen =&gt; 'Q',
            PieceType::Rook =&gt; 'R',
            PieceType::Bishop =&gt; 'B',
            PieceType::Knight =&gt; 'N',
            PieceType::Pawn =&gt; 'P',
        };
        if self.color == Color::White {
            ch
        } else {
            ch.to_ascii_lowercase()
        }
    }

    pub fn from_char(ch: char) -&gt; Option&lt;Piece&gt; {
        let piece_type = PieceType::from_char(ch)?;
        let color = if ch.is_ascii_uppercase() {
            Color::White
        } else {
            Color::Black
        };
        Some(Piece::new(piece_type, color))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Move {
    pub from: Square,
    pub to: Square,
    pub piece: PieceType,
    pub captured: Option&lt;PieceType&gt;,
    pub promotion: Option&lt;PieceType&gt;,
    pub is_castling: bool,
    pub is_en_passant: bool,
}

impl Move {
    pub fn new(from: Square, to: Square, piece: PieceType) -&gt; Self {
        Self {
            from,
            to,
            piece,
            captured: None,
            promotion: None,
            is_castling: false,
            is_en_passant: false,
        }
    }

    pub fn with_capture(mut self, captured: PieceType) -&gt; Self {
        self.captured = Some(captured);
        self
    }

    pub fn with_promotion(mut self, promotion: PieceType) -&gt; Self {
        self.promotion = Some(promotion);
        self
    }

    pub fn with_castling(mut self) -&gt; Self {
        self.is_castling = true;
        self
    }

    pub fn with_en_passant(mut self) -&gt; Self {
        self.is_en_passant = true;
        self
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CastlingRights {
    pub white_kingside: bool,
    pub white_queenside: bool,
    pub black_kingside: bool,
    pub black_queenside: bool,
}

impl CastlingRights {
    pub fn new() -&gt; Self {
        Self {
            white_kingside: true,
            white_queenside: true,
            black_kingside: true,
            black_queenside: true,
        }
    }

    pub fn none() -&gt; Self {
        Self {
            white_kingside: false,
            white_queenside: false,
            black_kingside: false,
            black_queenside: false,
        }
    }
}

#[derive(Debug, Clone)]
pub struct GameState {
    pub board: [Option&lt;Piece&gt;; 64],
    pub turn: Color,
    pub castling_rights: CastlingRights,
    pub en_passant_target: Option&lt;Square&gt;,
    pub halfmove_clock: u32,
    pub fullmove_number: u32,
    pub move_history: Vec&lt;Move&gt;,
}

impl GameState {
    pub fn new() -&gt; Self {
        let mut board = [None; 64];
        
        // White pieces
        board[0] = Some(Piece::new(PieceType::Rook, Color::White));
        board[1] = Some(Piece::new(PieceType::Knight, Color::White));
        board[2] = Some(Piece::new(PieceType::Bishop, Color::White));
        board[3] = Some(Piece::new(PieceType::Queen, Color::White));
        board[4] = Some(Piece::new(PieceType::King, Color::White));
        board[5] = Some(Piece::new(PieceType::Bishop, Color::White));
        board[6] = Some(Piece::new(PieceType::Knight, Color::White));
        board[7] = Some(Piece::new(PieceType::Rook, Color::White));
        
        for i in 8..16 {
            board[i] = Some(Piece::new(PieceType::Pawn, Color::White));
        }
        
        // Black pieces
        for i in 48..56 {
            board[i] = Some(Piece::new(PieceType::Pawn, Color::Black));
        }
        
        board[56] = Some(Piece::new(PieceType::Rook, Color::Black));
        board[57] = Some(Piece::new(PieceType::Knight, Color::Black));
        board[58] = Some(Piece::new(PieceType::Bishop, Color::Black));
        board[59] = Some(Piece::new(PieceType::Queen, Color::Black));
        board[60] = Some(Piece::new(PieceType::King, Color::Black));
        board[61] = Some(Piece::new(PieceType::Bishop, Color::Black));
        board[62] = Some(Piece::new(PieceType::Knight, Color::Black));
        board[63] = Some(Piece::new(PieceType::Rook, Color::Black));

        Self {
            board,
            turn: Color::White,
            castling_rights: CastlingRights::new(),
            en_passant_target: None,
            halfmove_clock: 0,
            fullmove_number: 1,
            move_history: Vec::new(),
        }
    }
}

pub const FILES: [char; 8] = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
pub const RANKS: [char; 8] = ['1', '2', '3', '4', '5', '6', '7', '8'];

pub fn square_to_algebraic(square: Square) -&gt; String {
    let file = square % 8;
    let rank = square / 8;
    format!("{}{}", FILES[file], RANKS[rank])
}

pub fn algebraic_to_square(algebraic: &amp;str) -&gt; Result&lt;Square, String&gt; {
    if algebraic.len() != 2 {
        return Err("Invalid algebraic notation".to_string());
    }
    
    let chars: Vec&lt;char&gt; = algebraic.chars().collect();
    let file = FILES.iter().position(|&amp;f| f == chars[0])
        .ok_or("Invalid file")?;
    let rank = RANKS.iter().position(|&amp;r| r == chars[1])
        .ok_or("Invalid rank")?;
    
    Ok(rank * 8 + file)
}</code></pre>
</div>
</div>

<script>
function toggleFile(id) {
    var content = document.getElementById(id);
    if (content.style.display === 'none') {
        content.style.display = 'block';
        // Highlight the code when first shown
        var codeBlock = content.querySelector('code');
        if (codeBlock && !codeBlock.classList.contains('hljs')) {
            hljs.highlightElement(codeBlock);
        }
    } else {
        content.style.display = 'none';
    }
}
</script>

    </main>
    <footer>
        <p>Generated from benchmark data. All implementations tested via Docker for consistency.</p>
        <p><a href="https://github.com/evaisse/the-great-analysis-challenge">View on GitHub</a></p>
    </footer>
</body>
</html>
