<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dart Source Code - The Great Analysis Challenge</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>üèÜ The Great Analysis Challenge</h1>
        <p class="subtitle">Multi-Language Chess Engine Comparison</p>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/evaisse/the-great-analysis-challenge">GitHub</a>
        </nav>
    </header>
    <main>
<h2>üéØ <a href="https://dart.dev/" target="_blank" rel="noopener">Dart</a> Implementation</h2>
<div class="breadcrumb"><a href="index.html">‚Üê Back to Comparison</a></div>
<div class="file-tree">
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Dockerfile')">üìÑ Dockerfile</button>
<pre id="Dockerfile" class="file-content" style="display:none;"><code class="language-dockerfile">FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies and Dart
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    wget \
    gnupg \
    apt-transport-https \
    ca-certificates \
    make \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install Dart
RUN curl -fsSL https://dl.google.com/linux/linux_signing_key.pub | gpg --dearmor -o /usr/share/keyrings/dart.gpg \
    &amp;&amp; echo 'deb [signed-by=/usr/share/keyrings/dart.gpg] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | tee /etc/apt/sources.list.d/dart_stable.list \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y dart \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Set the working directory.
WORKDIR /app

# Copy the pubspec files and get dependencies.
COPY pubspec.* ./
RUN dart pub get

# Copy the rest of the application source code.
COPY . .

# Compile the application.
RUN dart compile exe bin/main.dart -o bin/chess_engine

# Set the entrypoint for the container.
CMD ["./bin/chess_engine"]
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Makefile')">üìÑ Makefile</button>
<pre id="Makefile" class="file-content" style="display:none;"><code class="language-makefile">.PHONY: all build test analyze clean docker-build docker-test

# Default target - build the chess engine
all: build

# Build target - compile Dart to native executable
build:
	dart pub get
	dart compile exe bin/main.dart -o bin/chess_engine

# Run basic tests
test:
	dart test
	@echo "Running basic functionality test..."
	@echo -e "new\nmove e2e4\nmove e7e5\nexport\nquit" | ./bin/chess_engine | tail -1 | grep -q "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2" &amp;&amp; echo "‚úÖ Basic test passed" || (echo "‚ùå Basic test failed" &amp;&amp; exit 1)

# Static analysis and code quality
analyze:
	@echo "Running Dart static analysis..."
	dart analyze
	dart format --set-exit-if-changed .

# Clean build artifacts
clean:
	@echo "Cleaning Dart build artifacts..."
	rm -f bin/chess_engine
	rm -rf build/

# Docker targets
docker-build:
	docker build -t chess-dart .

docker-test: docker-build
	@echo "Testing Dart implementation in Docker..."
	docker run --rm -i chess-dart sh -c "echo -e 'new\\nmove e2e4\\nmove e7e5\\nexport\\nquit' | ./bin/chess_engine"

# Help target
help:
	@echo "Available targets:"
	@echo "  make         - Build the chess engine"
	@echo "  make test    - Run tests"
	@echo "  make analyze - Run static analysis"
	@echo "  make clean   - Clean build artifacts"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-test  - Test in Docker"
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('README_md')">üìÑ README.md</button>
<pre id="README_md" class="file-content" style="display:none;"><code class="language-markdown"># Dart Chess Engine

A chess engine implementation in Dart following the project specifications.

## Building

```bash
make build
# or
dart pub get
dart compile exe bin/main.dart -o bin/chess_engine
```

## Running

```bash
make
./bin/chess_engine
# or
dart run bin/main.dart
```

## Testing

```bash
make test
# or  
dart test
```

## Static Analysis

```bash
make analyze
# or
dart analyze
dart format --set-exit-if-changed .
```

## Docker

```bash
make docker-build
make docker-test
```

## Features

- ‚úÖ Basic chess rules and move validation
- ‚úÖ FEN parsing and generation
- ‚úÖ AI with minimax algorithm
- ‚úÖ Special moves (castling, en passant, promotion)
- ‚úÖ Perft testing for move generation verification
- ‚úÖ Command-line interface matching project specification

## Commands

- `new` - Start new game
- `move &lt;move&gt;` - Make a move (e.g., e2e4)
- `undo` - Undo last move
- `export` - Export position as FEN
- `ai &lt;depth&gt;` - AI move with specified depth
- `quit` - Exit program</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('bin_main_dart')">üìÑ bin/main.dart</button>
<pre id="bin_main_dart" class="file-content" style="display:none;"><code class="language-dart">import 'dart:io';
import 'package:chess_engine/chess_engine.dart';

void main() {
  final game = Game();
  final ai = AI();
  while (true) {
    final line = stdin.readLineSync();
    if (line == null) {
      break;
    }
    final parts = line.split(' ');
    final command = parts[0];
    switch (command) {
      case 'move':
        if (parts.length &lt; 2) {
          print('ERROR: Invalid move format');
          break;
        }
        final moveStr = parts[1];
        try {
          game.move(moveStr);
          game.printBoard();
          _checkGameState(game);
        } catch (e) {
          print(e);
        }
        break;
      case 'undo':
        game.undo();
        game.printBoard();
        break;
      case 'new':
        game.init();
        game.printBoard();
        break;
      case 'ai':
        if (parts.length &lt; 2) {
          print('ERROR: AI depth must be 1-5');
          break;
        }
        final depth = int.tryParse(parts[1]);
        if (depth == null || depth &lt; 1 || depth &gt; 5) {
          print('ERROR: AI depth must be 1-5');
          break;
        }
        final move = ai.findBestMove(game.board, depth);
        game.move(move.toString());
        game.printBoard();
        _checkGameState(game);
        break;
      case 'fen':
        if (parts.length &lt; 2) {
          print('ERROR: Invalid FEN string');
          break;
        }
        final fen = parts.sublist(1).join(' ');
        game.loadFen(fen);
        game.printBoard();
        break;
      case 'export':
        game.export();
        break;
      case 'eval':
        final score = ai.evaluate(game.board);
        print('Evaluation: $score');
        break;
      case 'perft':
        if (parts.length &lt; 2) {
          print('ERROR: perft depth must be provided');
          break;
        }
        final depth = int.tryParse(parts[1]);
        if (depth == null || depth &lt; 0) {
          print('ERROR: Invalid perft depth');
          break;
        }
        game.perft(depth);
        break;
      case 'help':
        print('''Available commands:
move &lt;from&gt;&lt;to&gt;[promotion]
undo
new
ai &lt;depth&gt;
fen &lt;string&gt;
export
eval
perft &lt;depth&gt;
help
quit''');
        break;
      case 'quit':
        exit(0);
      default:
        print('ERROR: Invalid command');
    }
  }
}

void _checkGameState(Game game) {
  final gameState = game.getGameState();
  if (gameState == GameState.checkmateWhiteWins) {
    print('CHECKMATE: White wins');
  } else if (gameState == GameState.checkmateBlackWins) {
    print('CHECKMATE: Black wins');
  } else if (gameState == GameState.stalemate) {
    print('STALEMATE: Draw');
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('chess_meta')">üìÑ chess.meta</button>
<pre id="chess_meta" class="file-content" style="display:none;"><code class="language-dart">{
  "language": "dart",
  "version": "3.0",
  "author": "Dart Implementation",
  "build": "dart pub get &amp;&amp; dart compile exe bin/main.dart -o bin/chess_engine",
  "run": "./bin/chess_engine",
  "analyze": "dart analyze &amp;&amp; dart format --set-exit-if-changed .",
  "test": "dart test",
  "features": ["perft", "fen", "ai", "castling", "en_passant", "promotion"],
  "max_ai_depth": 5,
  "estimated_perft4_ms": 900
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_chess_engine_dart')">üìÑ lib/chess_engine.dart</button>
<pre id="lib_chess_engine_dart" class="file-content" style="display:none;"><code class="language-dart">export 'src/board.dart';
export 'src/game.dart';
export 'src/move.dart';
export 'src/piece.dart';
export 'src/ai.dart';
export 'src/game_state.dart';
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_ai_dart')">üìÑ lib/src/ai.dart</button>
<pre id="lib_src_ai_dart" class="file-content" style="display:none;"><code class="language-dart">import 'dart:math';

import 'package:chess_engine/chess_engine.dart';

class AI {
  static const _materialValues = {
    PieceType.pawn: 100,
    PieceType.knight: 320,
    PieceType.bishop: 330,
    PieceType.rook: 500,
    PieceType.queen: 900,
    PieceType.king: 20000,
  };

  Move findBestMove(Board board, int depth) {
    double bestValue = double.negativeInfinity;
    Move? bestMove;

    for (final move in board.generateMoves()) {
      final newBoard = board.clone();
      newBoard.move(move.toString());
      final value = _minimax(
        newBoard,
        depth - 1,
        double.negativeInfinity,
        double.infinity,
        false,
      );
      if (value &gt; bestValue) {
        bestValue = value;
        bestMove = move;
      }
    }
    return bestMove!;
  }

  double _minimax(
    Board board,
    int depth,
    double alpha,
    double beta,
    bool maximizingPlayer,
  ) {
    if (depth == 0) {
      return evaluate(board);
    }

    final moves = board.generateMoves();
    if (moves.isEmpty) {
      // TODO: Check for checkmate/stalemate
      return 0;
    }

    if (maximizingPlayer) {
      double maxEval = double.negativeInfinity;
      for (final move in moves) {
        final newBoard = board.clone();
        newBoard.move(move.toString());
        final eval = _minimax(newBoard, depth - 1, alpha, beta, false);
        maxEval = max(maxEval, eval);
        alpha = max(alpha, eval);
        if (beta &lt;= alpha) {
          break;
        }
      }
      return maxEval;
    } else {
      double minEval = double.infinity;
      for (final move in moves) {
        final newBoard = board.clone();
        newBoard.move(move.toString());
        final eval = _minimax(newBoard, depth - 1, alpha, beta, true);
        minEval = min(minEval, eval);
        beta = min(beta, eval);
        if (beta &lt;= alpha) {
          break;
        }
      }
      return minEval;
    }
  }

  double evaluate(Board board) {
    double score = 0;
    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = board.squares[i][j];
        if (piece != null) {
          final value = _materialValues[piece.type]!;
          if (piece.color == PieceColor.white) {
            score += value;
          } else {
            score -= value;
          }
        }
      }
    }
    return score;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_board_dart')">üìÑ lib/src/board.dart</button>
<pre id="lib_src_board_dart" class="file-content" style="display:none;"><code class="language-dart">import 'package:chess_engine/chess_engine.dart';

class Board {
  late List&lt;List&lt;Piece?&gt;&gt; squares;
  late String turn;
  ({int row, int col})? _enPassantTarget;
  late String _castlingRights;
  late int _halfmoveClock;
  late int _fullmoveNumber;

  Board._(
    this.squares,
    this.turn,
    this._enPassantTarget,
    this._castlingRights,
    this._halfmoveClock,
    this._fullmoveNumber,
  );

  Board.empty() {
    squares = List.generate(8, (_) =&gt; List.filled(8, null));
    turn = 'w';
    _castlingRights = 'KQkq';
    _halfmoveClock = 0;
    _fullmoveNumber = 1;
  }

  Board.fromFen(String fen) {
    squares = List.generate(8, (_) =&gt; List.filled(8, null));
    final parts = fen.split(' ');
    final piecePlacement = parts[0];
    turn = parts[1];
    _castlingRights = parts[2];
    if (parts[3] != '-') {
      _enPassantTarget = _parseSquare(parts[3]);
    } else {
      _enPassantTarget = null;
    }
    _halfmoveClock = parts.length &gt; 4 ? int.tryParse(parts[4]) ?? 0 : 0;
    _fullmoveNumber = parts.length &gt; 5 ? int.tryParse(parts[5]) ?? 1 : 1;

    int row = 0;
    int col = 0;
    for (final char in piecePlacement.split('')) {
      if (char == '/') {
        row++;
        col = 0;
      } else if (int.tryParse(char) != null) {
        col += int.parse(char);
      } else {
        squares[row][col] = Piece.fromChar(char);
        col++;
      }
    }
  }

  @override
  String toString() {
    final buffer = StringBuffer();
    buffer.writeln('  a b c d e f g h');
    for (int i = 0; i &lt; 8; i++) {
      buffer.write('${8 - i} ');
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        buffer.write('${piece?.toChar() ?? '.'} ');
      }
      buffer.writeln('${8 - i}');
    }
    buffer.writeln('  a b c d e f g h');
    buffer.writeln('');
    buffer.writeln('${turn == 'w' ? 'White' : 'Black'} to move');
    return buffer.toString();
  }

  void move(String moveStr) {
    final from = _parseSquare(moveStr.substring(0, 2));
    final to = _parseSquare(moveStr.substring(2, 4));
    PieceType? promotion;
    if (moveStr.length == 5) {
      promotion = Piece.charToType(moveStr.substring(4, 5).toLowerCase());
    }

    final piece = squares[from.row][from.col]!;
    final targetPiece = squares[to.row][to.col];
    final isPawnMove = piece.type == PieceType.pawn;
    bool isCapture = targetPiece != null;

    // Handle castling
    if (piece.type == PieceType.king &amp;&amp; (from.col - to.col).abs() == 2) {
      if (to.col == 6) {
        // Kingside
        final rook = squares[from.row][7];
        squares[from.row][7] = null;
        squares[from.row][5] = rook;
      } else {
        // Queenside
        final rook = squares[from.row][0];
        squares[from.row][0] = null;
        squares[from.row][3] = rook;
      }
    }

    squares[from.row][from.col] = null;

    // En passant capture
    if (piece.type == PieceType.pawn &amp;&amp;
        to.row == _enPassantTarget?.row &amp;&amp;
        to.col == _enPassantTarget?.col) {
      squares[from.row][to.col] = null;
      isCapture = true;
    }

    if (promotion != null) {
      squares[to.row][to.col] = Piece(promotion, piece.color);
    } else {
      squares[to.row][to.col] = piece;
    }

    if (isPawnMove || isCapture) {
      _halfmoveClock = 0;
    } else {
      _halfmoveClock += 1;
    }

    // Set en passant target
    if (piece.type == PieceType.pawn &amp;&amp; (to.row - from.row).abs() == 2) {
      _enPassantTarget = (row: (from.row + to.row) ~/ 2, col: from.col);
    } else {
      _enPassantTarget = null;
    }

    // Update castling rights
    if (piece.type == PieceType.king) {
      if (piece.color == PieceColor.white) {
        _castlingRights =
            _castlingRights.replaceAll('K', '').replaceAll('Q', '');
      } else {
        _castlingRights =
            _castlingRights.replaceAll('k', '').replaceAll('q', '');
      }
    } else if (piece.type == PieceType.rook) {
      if (from.row == 7 &amp;&amp; from.col == 0 &amp;&amp; piece.color == PieceColor.white) {
        _castlingRights = _castlingRights.replaceAll('Q', '');
      } else if (from.row == 7 &amp;&amp;
          from.col == 7 &amp;&amp;
          piece.color == PieceColor.white) {
        _castlingRights = _castlingRights.replaceAll('K', '');
      } else if (from.row == 0 &amp;&amp;
          from.col == 0 &amp;&amp;
          piece.color == PieceColor.black) {
        _castlingRights = _castlingRights.replaceAll('q', '');
      } else if (from.row == 0 &amp;&amp;
          from.col == 7 &amp;&amp;
          piece.color == PieceColor.black) {
        _castlingRights = _castlingRights.replaceAll('k', '');
      }
    }

    turn = turn == 'w' ? 'b' : 'w';
    if (turn == 'w') {
      _fullmoveNumber += 1;
    }
  }

  ({int row, int col}) _parseSquare(String square) {
    final col = square.codeUnitAt(0) - 'a'.codeUnitAt(0);
    final row = 8 - int.parse(square.substring(1));
    return (row: row, col: col);
  }

  Board clone() {
    final newSquares = List.generate(8, (i) =&gt; List.of(squares[i]));
    return Board._(
      newSquares,
      turn,
      _enPassantTarget,
      _castlingRights,
      _halfmoveClock,
      _fullmoveNumber,
    );
  }

  String toFen() {
    final buffer = StringBuffer();
    for (int i = 0; i &lt; 8; i++) {
      int empty = 0;
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece == null) {
          empty++;
        } else {
          if (empty &gt; 0) {
            buffer.write(empty);
            empty = 0;
          }
          buffer.write(piece.toChar());
        }
      }
      if (empty &gt; 0) {
        buffer.write(empty);
      }
      if (i &lt; 7) {
        buffer.write('/');
      }
    }
    final castling = (_castlingRights.isEmpty || _castlingRights == '-')
        ? '-'
        : _castlingRights;
    buffer.write(' $turn $castling ');
    if (_enPassantTarget != null) {
      buffer.write(
        '${String.fromCharCode('a'.codeUnitAt(0) + _enPassantTarget!.col)}${8 - _enPassantTarget!.row}',
      );
    } else {
      buffer.write('-');
    }
    buffer.write(' $_halfmoveClock $_fullmoveNumber');
    return buffer.toString();
  }

  List&lt;Move&gt; generateMoves() {
    final pseudoLegalMoves = &lt;Move&gt;[];
    final playerColor = turn == 'w' ? PieceColor.white : PieceColor.black;

    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece != null &amp;&amp; piece.color == playerColor) {
          if (piece.type == PieceType.pawn) {
            _generatePawnMoves(i, j, playerColor, pseudoLegalMoves);
          } else if (piece.type == PieceType.knight) {
            _generateKnightMoves(i, j, playerColor, pseudoLegalMoves);
          } else if (piece.type == PieceType.bishop) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, -1],
              [-1, 1],
              [1, -1],
              [1, 1],
            ]);
          } else if (piece.type == PieceType.rook) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ]);
          } else if (piece.type == PieceType.queen) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, -1],
              [-1, 1],
              [1, -1],
              [1, 1],
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ]);
          } else if (piece.type == PieceType.king) {
            _generateKingMoves(i, j, playerColor, pseudoLegalMoves);
          }
        }
      }
    }

    final legalMoves = &lt;Move&gt;[];
    for (final move in pseudoLegalMoves) {
      final newBoard = clone();
      newBoard.move(move.toString());
      if (!newBoard.isKingInCheck(playerColor)) {
        legalMoves.add(move);
      }
    }

    return legalMoves;
  }

  void _generatePawnMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final direction = color == PieceColor.white ? -1 : 1;
    final startRow = color == PieceColor.white ? 6 : 1;
    final promotionRow = color == PieceColor.white ? 0 : 7;

    // Single move
    if (row + direction &gt;= 0 &amp;&amp;
        row + direction &lt; 8 &amp;&amp;
        squares[row + direction][col] == null) {
      if (row + direction == promotionRow) {
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.queen),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.rook),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.bishop),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.knight),
        );
      } else {
        moves.add(Move(row, col, row + direction, col));
      }

      // Double move
      if (row == startRow &amp;&amp; squares[row + 2 * direction][col] == null) {
        moves.add(Move(row, col, row + 2 * direction, col));
      }
    }

    // Captures
    for (int dcol = -1; dcol &lt;= 1; dcol += 2) {
      if (col + dcol &gt;= 0 &amp;&amp; col + dcol &lt; 8) {
        if (row + direction &gt;= 0 &amp;&amp; row + direction &lt; 8) {
          final dest = squares[row + direction][col + dcol];
          if (dest != null &amp;&amp; dest.color != color) {
            if (row + direction == promotionRow) {
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.queen,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.rook,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.bishop,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.knight,
                ),
              );
            } else {
              moves.add(Move(row, col, row + direction, col + dcol));
            }
          } else if (_enPassantTarget != null &amp;&amp;
              _enPassantTarget!.row == row + direction &amp;&amp;
              _enPassantTarget!.col == col + dcol) {
            moves.add(Move(row, col, row + direction, col + dcol));
          }
        }
      }
    }
  }

  void _generateKnightMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final offsets = [
      [-2, -1],
      [-2, 1],
      [-1, -2],
      [-1, 2],
      [1, -2],
      [1, 2],
      [2, -1],
      [2, 1],
    ];
    for (final offset in offsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final dest = squares[newRow][newCol];
        if (dest == null || dest.color != color) {
          moves.add(Move(row, col, newRow, newCol));
        }
      }
    }
  }

  void _generateSlidingMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
    List&lt;List&lt;int&gt;&gt; directions,
  ) {
    for (final dir in directions) {
      for (int i = 1; i &lt; 8; i++) {
        final newRow = row + i * dir[0];
        final newCol = col + i * dir[1];
        if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
          final dest = squares[newRow][newCol];
          if (dest == null) {
            moves.add(Move(row, col, newRow, newCol));
          } else {
            if (dest.color != color) {
              moves.add(Move(row, col, newRow, newCol));
            }
            break;
          }
        } else {
          break;
        }
      }
    }
  }

  void _generateKingMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final offsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ];
    for (final offset in offsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final dest = squares[newRow][newCol];
        if (dest == null || dest.color != color) {
          moves.add(Move(row, col, newRow, newCol));
        }
      }
    }

    // Castling
    if (color == PieceColor.white) {
      if (_castlingRights.contains('K') &amp;&amp;
          squares[7][5] == null &amp;&amp;
          squares[7][6] == null) {
        moves.add(Move(7, 4, 7, 6));
      }
      if (_castlingRights.contains('Q') &amp;&amp;
          squares[7][1] == null &amp;&amp;
          squares[7][2] == null &amp;&amp;
          squares[7][3] == null) {
        moves.add(Move(7, 4, 7, 2));
      }
    } else {
      if (_castlingRights.contains('k') &amp;&amp;
          squares[0][5] == null &amp;&amp;
          squares[0][6] == null) {
        moves.add(Move(0, 4, 0, 6));
      }
      if (_castlingRights.contains('q') &amp;&amp;
          squares[0][1] == null &amp;&amp;
          squares[0][2] == null &amp;&amp;
          squares[0][3] == null) {
        moves.add(Move(0, 4, 0, 2));
      }
    }
  }

  int perft(int depth) {
    if (depth == 0) {
      return 1;
    }

    int nodes = 0;
    final moves = generateMoves();
    for (final move in moves) {
      final newBoard = clone();
      newBoard.move(move.toString());
      nodes += newBoard.perft(depth - 1);
    }
    return nodes;
  }

  bool isSquareAttacked(int row, int col, PieceColor attackerColor) {
    // Check for pawn attacks
    final direction = attackerColor == PieceColor.white ? -1 : 1;
    if (row + direction &gt;= 0 &amp;&amp; row + direction &lt; 8) {
      if (col - 1 &gt;= 0) {
        final piece = squares[row + direction][col - 1];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.pawn) {
          return true;
        }
      }
      if (col + 1 &lt; 8) {
        final piece = squares[row + direction][col + 1];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.pawn) {
          return true;
        }
      }
    }

    // Check for knight attacks
    final knightOffsets = [
      [-2, -1],
      [-2, 1],
      [-1, -2],
      [-1, 2],
      [1, -2],
      [1, 2],
      [2, -1],
      [2, 1],
    ];
    for (final offset in knightOffsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final piece = squares[newRow][newCol];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.knight) {
          return true;
        }
      }
    }

    // Check for sliding attacks (rooks, bishops, queens)
    final slidingDirections = {
      PieceType.rook: [
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1],
      ],
      PieceType.bishop: [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1],
      ],
      PieceType.queen: [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1],
      ],
    };

    for (final pieceType in slidingDirections.keys) {
      for (final dir in slidingDirections[pieceType]!) {
        for (int i = 1; i &lt; 8; i++) {
          final newRow = row + i * dir[0];
          final newCol = col + i * dir[1];
          if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
            final piece = squares[newRow][newCol];
            if (piece != null) {
              if (piece.color == attackerColor &amp;&amp;
                  (piece.type == pieceType || piece.type == PieceType.queen)) {
                return true;
              }
              break;
            }
          } else {
            break;
          }
        }
      }
    }

    // Check for king attacks
    final kingOffsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ];
    for (final offset in kingOffsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final piece = squares[newRow][newCol];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.king) {
          return true;
        }
      }
    }

    return false;
  }

  bool isKingInCheck(PieceColor kingColor) {
    int kingRow = -1;
    int kingCol = -1;
    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece != null &amp;&amp;
            piece.type == PieceType.king &amp;&amp;
            piece.color == kingColor) {
          kingRow = i;
          kingCol = j;
          break;
        }
      }
    }
    return isSquareAttacked(
      kingRow,
      kingCol,
      kingColor == PieceColor.white ? PieceColor.black : PieceColor.white,
    );
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_game_dart')">üìÑ lib/src/game.dart</button>
<pre id="lib_src_game_dart" class="file-content" style="display:none;"><code class="language-dart">import 'package:collection/collection.dart';
import 'package:chess_engine/chess_engine.dart';

class Game {
  late List&lt;Board&gt; history;

  Game() {
    init();
  }

  void init() {
    history = [
      Board.fromFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')
    ];
  }

  Board get board =&gt; history.last;

  void printBoard() {
    print(board.toString());
  }

  void move(String moveStr) {
    final legalMoves = board.generateMoves();
    final move = legalMoves.firstWhereOrNull((m) =&gt; m.toString() == moveStr);

    if (move == null) {
      throw Exception('ERROR: Illegal move');
    }

    final newBoard = board.clone();
    newBoard.move(move.toString());
    history.add(newBoard);
  }

  void undo() {
    if (history.length &gt; 1) {
      history.removeLast();
    }
  }

  void loadFen(String fen) {
    history = [Board.fromFen(fen)];
  }

  void export() {
    print('FEN: ${board.toFen()}');
  }

  void perft(int depth) {
    final count = board.perft(depth);
    print('Perft $depth: $count');
  }

  GameState getGameState() {
    final legalMoves = board.generateMoves();
    if (legalMoves.isNotEmpty) {
      return GameState.inProgress;
    }

    final playerColor = board.turn == 'w' ? PieceColor.white : PieceColor.black;
    if (board.isKingInCheck(playerColor)) {
      return playerColor == PieceColor.white
          ? GameState.checkmateBlackWins
          : GameState.checkmateWhiteWins;
    } else {
      return GameState.stalemate;
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_game_state_dart')">üìÑ lib/src/game_state.dart</button>
<pre id="lib_src_game_state_dart" class="file-content" style="display:none;"><code class="language-dart">enum GameState { inProgress, checkmateWhiteWins, checkmateBlackWins, stalemate }
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_move_dart')">üìÑ lib/src/move.dart</button>
<pre id="lib_src_move_dart" class="file-content" style="display:none;"><code class="language-dart">import 'package:chess_engine/chess_engine.dart';

class Move {
  final int fromRow;
  final int fromCol;
  final int toRow;
  final int toCol;
  final PieceType? promotion;

  Move(this.fromRow, this.fromCol, this.toRow, this.toCol, {this.promotion});

  @override
  String toString() {
    return '${_colToChar(fromCol)}${8 - fromRow}${_colToChar(toCol)}${8 - toRow}${promotion != null ? _typeToChar(promotion!) : ''}';
  }

  static String _colToChar(int col) {
    return String.fromCharCode('a'.codeUnitAt(0) + col);
  }

  static String _typeToChar(PieceType type) {
    switch (type) {
      case PieceType.queen:
        return 'q';
      case PieceType.rook:
        return 'r';
      case PieceType.bishop:
        return 'b';
      case PieceType.knight:
        return 'n';
      default:
        return '';
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_piece_dart')">üìÑ lib/src/piece.dart</button>
<pre id="lib_src_piece_dart" class="file-content" style="display:none;"><code class="language-dart">enum PieceType { king, queen, rook, bishop, knight, pawn }

enum PieceColor { white, black }

class Piece {
  final PieceType type;
  final PieceColor color;

  Piece(this.type, this.color);

  factory Piece.fromChar(String char) {
    final color =
        char.toUpperCase() == char ? PieceColor.white : PieceColor.black;
    final type = charToType(char.toLowerCase());
    return Piece(type, color);
  }

  String toChar() {
    final char = _typeToChar(type);
    return color == PieceColor.white ? char.toUpperCase() : char.toLowerCase();
  }

  static PieceType charToType(String char) {
    switch (char) {
      case 'k':
        return PieceType.king;
      case 'q':
        return PieceType.queen;
      case 'r':
        return PieceType.rook;
      case 'b':
        return PieceType.bishop;
      case 'n':
        return PieceType.knight;
      case 'p':
        return PieceType.pawn;
      default:
        throw ArgumentError('Invalid piece character: $char');
    }
  }

  static String _typeToChar(PieceType type) {
    switch (type) {
      case PieceType.king:
        return 'k';
      case PieceType.queen:
        return 'q';
      case PieceType.rook:
        return 'r';
      case PieceType.bishop:
        return 'b';
      case PieceType.knight:
        return 'n';
      case PieceType.pawn:
        return 'p';
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('pubspec_lock')">üìÑ pubspec.lock</button>
<pre id="pubspec_lock" class="file-content" style="display:none;"><code class="language-dart"># Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: c209688d9f5a5f26b2fb47a188131a6fb9e876ae9e47af3737c0b4f58a93470d
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "91.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: f51c8499b35f9b26820cfe914828a6a98a94efd5cc78b37bb7d03debae3a1d08
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "8.4.1"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.1.2"
  cli_config:
    dependency: transitive
    description:
      name: cli_config
      sha256: ac20a183a07002b700f0c25e61b7ee46b23c309d76ab7b7640a028f18e4d99ec
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.2.0"
  collection:
    dependency: "direct main"
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.19.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.1.2"
  coverage:
    dependency: transitive
    description:
      name: coverage
      sha256: "5da775aa218eaf2151c721b16c01c7676fbfdd99cebba2bf64e8b807a28ff94d"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.15.0"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.0.7"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "7.0.1"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "4.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.1.3"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "4.1.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.0.5"
  js:
    dependency: transitive
    description:
      name: js
      sha256: "53385261521cc4a0c4658fd0ad07a7d14591cf8fc33abbceae306ddb974888dc"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.7.2"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.12.17"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "23f08335362185a5ea2ad3a4e597f1375e78bce8a040df5c600c8d3552ef2394"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.17.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.0.0"
  node_preamble:
    dependency: transitive
    description:
      name: node_preamble
      sha256: "6e7eac89047ab8a8d26cf16127b5ed26de65209847630400f9aefd7cd5c730db"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.0.2"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.2.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.9.1"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.5.2"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.2.0"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.4.2"
  shelf_packages_handler:
    dependency: transitive
    description:
      name: shelf_packages_handler
      sha256: "89f967eca29607c933ba9571d838be31d67f53f6e4ee15147d5dc2934fee1b1e"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.0.2"
  shelf_static:
    dependency: transitive
    description:
      name: shelf_static
      sha256: c87c3875f91262785dade62d135760c2c69cb217ac759485334c5857ad89f6e3
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.1.3"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "3632775c8e90d6c9712f883e633716432a27758216dfb61bd86a8321c0580925"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.0.0"
  source_map_stack_trace:
    dependency: transitive
    description:
      name: source_map_stack_trace
      sha256: c0713a43e323c3302c2abe2a1cc89aa057a387101ebd280371d6a6c9fa68516b
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.1.2"
  source_maps:
    dependency: transitive
    description:
      name: source_maps
      sha256: "190222579a448b03896e0ca6eca5998fa810fda630c1d65e2f78b3f638f54812"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.10.13"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.10.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.2.2"
  test:
    dependency: "direct dev"
    description:
      name: test
      sha256: "75906bf273541b676716d1ca7627a17e4c4070a3a16272b7a3dc7da3b9f3f6b7"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.26.3"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: ab2726c1a94d3176a45960b6234466ec367179b87dd74f1611adb1f3b5fb9d55
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.7.7"
  test_core:
    dependency: transitive
    description:
      name: test_core
      sha256: "0cc24b5ff94b38d2ae73e1eb43cc302b77964fbf67abad1e296025b78deb53d0"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "0.6.12"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.4.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "15.0.2"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "592ab6e2892f67760543fb712ff0177f4ec76c031f02f5b4ff8d3fc5eb9fb61a"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.1.4"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.0.3"
  webkit_inspection_protocol:
    dependency: transitive
    description:
      name: webkit_inspection_protocol
      sha256: "87d3f2333bb240704cd3f1c6b5b7acd8a10e7f0bc28c28dcf14e782014f4a572"
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "1.2.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://jfrog.int.bourso.net/artifactory/api/pub/web-v-pub/"
    source: hosted
    version: "3.1.3"
sdks:
  dart: "&gt;=3.9.0 &lt;4.0.0"
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('pubspec_yaml')">üìÑ pubspec.yaml</button>
<pre id="pubspec_yaml" class="file-content" style="display:none;"><code class="language-yaml">name: chess_engine
description: A command-line chess engine.
version: 1.0.0
environment:
  sdk: '&gt;=3.0.0 &lt;4.0.0'
dependencies:
  collection: ^1.18.0
dev_dependencies:
  test: ^1.25.0
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('test_basic_test_dart')">üìÑ test/basic_test.dart</button>
<pre id="test_basic_test_dart" class="file-content" style="display:none;"><code class="language-dart">import 'package:test/test.dart';
import 'package:chess_engine/chess_engine.dart';

void main() {
  test('new game starts at initial position', () {
    final game = Game();
    expect(
      game.board.toFen(),
      'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
    );
  });
}
</code></pre>
</div>
</div>

<script>
function toggleFile(id) {
    var content = document.getElementById(id);
    if (content.style.display === 'none') {
        content.style.display = 'block';
        // Highlight the code when first shown
        var codeBlock = content.querySelector('code');
        if (codeBlock && !codeBlock.classList.contains('hljs')) {
            hljs.highlightElement(codeBlock);
        }
    } else {
        content.style.display = 'none';
    }
}
</script>

    </main>
    <footer>
        <p>Generated from benchmark data. All implementations tested via Docker for consistency.</p>
        <p><a href="https://github.com/evaisse/the-great-analysis-challenge">View on GitHub</a></p>
    </footer>
</body>
</html>
