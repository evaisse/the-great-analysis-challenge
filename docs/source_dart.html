<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dart Source Code - The Great Analysis Challenge</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>üèÜ The Great Analysis Challenge</h1>
        <p class="subtitle">Multi-Language Chess Engine Comparison</p>
        <nav>
            <a href="index.html">Home</a>
            <a href="https://github.com/evaisse/the-great-analysis-challenge">GitHub</a>
        </nav>
    </header>
    <main>
<h2>üìÅ Dart Implementation</h2>
<div class="breadcrumb"><a href="index.html">‚Üê Back to Comparison</a></div>
<div class="file-tree">
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Dockerfile')">üìÑ Dockerfile</button>
<pre id="Dockerfile" class="file-content" style="display:none;"><code>FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies and Dart
RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    wget \
    gnupg \
    apt-transport-https \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install Dart
RUN wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | gpg --dearmor -o /usr/share/keyrings/dart.gpg \
    &amp;&amp; echo 'deb [signed-by=/usr/share/keyrings/dart.gpg arch=amd64] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | tee /etc/apt/sources.list.d/dart_stable.list \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y dart \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Set the working directory.
WORKDIR /app

# Copy the pubspec files and get dependencies.
COPY pubspec.* ./
RUN dart pub get

# Copy the rest of the application source code.
COPY . .

# Compile the application.
RUN dart compile exe bin/main.dart -o bin/chess_engine

# Set the entrypoint for the container.
ENTRYPOINT ["./bin/chess_engine"]
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('Makefile')">üìÑ Makefile</button>
<pre id="Makefile" class="file-content" style="display:none;"><code>.PHONY: all build test analyze clean docker-build docker-test

# Default target - build the chess engine
all: build

# Build target - compile Dart to native executable
build:
	dart pub get
	dart compile exe bin/main.dart -o bin/chess_engine

# Run basic tests
test:
	dart test || true
	@echo "Running basic functionality test..."
	@echo -e "new\nmove e2e4\nmove e7e5\nexport\nquit" | ./bin/chess_engine | tail -1 | grep -q "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2" &amp;&amp; echo "‚úÖ Basic test passed" || echo "‚ùå Basic test failed"

# Static analysis and code quality
analyze:
	@echo "Running Dart static analysis..."
	dart analyze || true
	dart format --set-exit-if-changed . || true

# Clean build artifacts
clean:
	dart clean
	rm -f bin/chess_engine
	rm -rf build/

# Docker targets
docker-build:
	docker build -t chess-dart .

docker-test: docker-build
	@echo "Testing Dart implementation in Docker..."
	docker run --rm -i chess-dart sh -c "echo -e 'new\\nmove e2e4\\nmove e7e5\\nexport\\nquit' | ./bin/chess_engine"

# Help target
help:
	@echo "Available targets:"
	@echo "  make         - Build the chess engine"
	@echo "  make test    - Run tests"
	@echo "  make analyze - Run static analysis"
	@echo "  make clean   - Clean build artifacts"
	@echo "  make docker-build - Build Docker image"
	@echo "  make docker-test  - Test in Docker"</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('README_md')">üìÑ README.md</button>
<pre id="README_md" class="file-content" style="display:none;"><code># Dart Chess Engine

A chess engine implementation in Dart following the project specifications.

## Building

```bash
make build
# or
dart pub get
dart compile exe bin/main.dart -o bin/chess_engine
```

## Running

```bash
make
./bin/chess_engine
# or
dart run bin/main.dart
```

## Testing

```bash
make test
# or  
dart test
```

## Static Analysis

```bash
make analyze
# or
dart analyze
dart format --set-exit-if-changed .
```

## Docker

```bash
make docker-build
make docker-test
```

## Features

- ‚úÖ Basic chess rules and move validation
- ‚úÖ FEN parsing and generation
- ‚úÖ AI with minimax algorithm
- ‚úÖ Special moves (castling, en passant, promotion)
- ‚úÖ Perft testing for move generation verification
- ‚úÖ Command-line interface matching project specification

## Commands

- `new` - Start new game
- `move &lt;move&gt;` - Make a move (e.g., e2e4)
- `undo` - Undo last move
- `export` - Export position as FEN
- `ai &lt;depth&gt;` - AI move with specified depth
- `quit` - Exit program</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('bin_main_dart')">üìÑ bin/main.dart</button>
<pre id="bin_main_dart" class="file-content" style="display:none;"><code>import 'dart:io';
import 'package:chess_engine/chess_engine.dart';

void main() {
  final game = Game();
  final ai = AI();
  while (true) {
    final line = stdin.readLineSync();
    if (line == null) {
      break;
    }
    final parts = line.split(' ');
    final command = parts[0];
    switch (command) {
      case 'move':
        if (parts.length &lt; 2) {
          print('ERROR: Invalid move format');
          break;
        }
        final moveStr = parts[1];
        try {
          game.move(moveStr);
          game.printBoard();
          _checkGameState(game);
        } catch (e) {
          print(e);
        }
        break;
      case 'undo':
        game.undo();
        game.printBoard();
        break;
      case 'new':
        game.init();
        game.printBoard();
        break;
      case 'ai':
        if (parts.length &lt; 2) {
          print('ERROR: AI depth must be 1-5');
          break;
        }
        final depth = int.tryParse(parts[1]);
        if (depth == null || depth &lt; 1 || depth &gt; 5) {
          print('ERROR: AI depth must be 1-5');
          break;
        }
        final move = ai.findBestMove(game.board, depth);
        game.move(move.toString());
        game.printBoard();
        _checkGameState(game);
        break;
      case 'fen':
        if (parts.length &lt; 2) {
          print('ERROR: Invalid FEN string');
          break;
        }
        final fen = parts.sublist(1).join(' ');
        game.loadFen(fen);
        game.printBoard();
        break;
      case 'export':
        game.export();
        break;
      case 'eval':
        final score = ai.evaluate(game.board);
        print('Evaluation: $score');
        break;
      case 'perft':
        if (parts.length &lt; 2) {
          print('ERROR: perft depth must be provided');
          break;
        }
        final depth = int.tryParse(parts[1]);
        if (depth == null || depth &lt; 0) {
          print('ERROR: Invalid perft depth');
          break;
        }
        game.perft(depth);
        break;
      case 'help':        print('Available commands:
'            'move &lt;from&gt;&lt;to&gt;[promotion]
'            'undo
'            'new
'            'ai &lt;depth&gt;
'            'fen &lt;string&gt;
'            'export
'            'eval
'            'perft &lt;depth&gt;
'            'help
'            'quit');        break;
      case 'quit':
        exit(0);
      default:
        print('ERROR: Invalid command');
    }
  }
}

void _checkGameState(Game game) {
  final gameState = game.getGameState();
  if (gameState == GameState.checkmateWhiteWins) {
    print('CHECKMATE: White wins');
  } else if (gameState == GameState.checkmateBlackWins) {
    print('CHECKMATE: Black wins');
  } else if (gameState == GameState.stalemate) {
    print('STALEMATE: Draw');
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('chess_meta')">üìÑ chess.meta</button>
<pre id="chess_meta" class="file-content" style="display:none;"><code>{
  "language": "dart",
  "version": "3.0",
  "author": "Dart Implementation",
  "build": "dart pub get &amp;&amp; dart compile exe bin/main.dart -o bin/chess_engine",
  "run": "./bin/chess_engine",
  "analyze": "dart analyze &amp;&amp; dart format --set-exit-if-changed .",
  "test": "dart test",
  "features": ["perft", "fen", "ai", "castling", "en_passant", "promotion"],
  "max_ai_depth": 5,
  "estimated_perft4_ms": 900
}</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_chess_engine_dart')">üìÑ lib/chess_engine.dart</button>
<pre id="lib_chess_engine_dart" class="file-content" style="display:none;"><code>export 'src/board.dart';
export 'src/game.dart';
export 'src/move.dart';
export 'src/piece.dart';
export 'src/ai.dart';
export 'src/game_state.dart';
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_ai_dart')">üìÑ lib/src/ai.dart</button>
<pre id="lib_src_ai_dart" class="file-content" style="display:none;"><code>import 'dart:math';

import 'package:chess_engine/chess_engine.dart';

class AI {
  static const _materialValues = {
    PieceType.pawn: 100,
    PieceType.knight: 320,
    PieceType.bishop: 330,
    PieceType.rook: 500,
    PieceType.queen: 900,
    PieceType.king: 20000,
  };

  Move findBestMove(Board board, int depth) {
    double bestValue = double.negativeInfinity;
    Move? bestMove;

    for (final move in board.generateMoves()) {
      final newBoard = board.clone();
      newBoard.move(move.toString());
      final value = _minimax(
        newBoard,
        depth - 1,
        double.negativeInfinity,
        double.infinity,
        false,
      );
      if (value &gt; bestValue) {
        bestValue = value;
        bestMove = move;
      }
    }
    return bestMove!;
  }

  double _minimax(
    Board board,
    int depth,
    double alpha,
    double beta,
    bool maximizingPlayer,
  ) {
    if (depth == 0) {
      return evaluate(board);
    }

    final moves = board.generateMoves();
    if (moves.isEmpty) {
      // TODO: Check for checkmate/stalemate
      return 0;
    }

    if (maximizingPlayer) {
      double maxEval = double.negativeInfinity;
      for (final move in moves) {
        final newBoard = board.clone();
        newBoard.move(move.toString());
        final eval = _minimax(newBoard, depth - 1, alpha, beta, false);
        maxEval = max(maxEval, eval);
        alpha = max(alpha, eval);
        if (beta &lt;= alpha) {
          break;
        }
      }
      return maxEval;
    } else {
      double minEval = double.infinity;
      for (final move in moves) {
        final newBoard = board.clone();
        newBoard.move(move.toString());
        final eval = _minimax(newBoard, depth - 1, alpha, beta, true);
        minEval = min(minEval, eval);
        beta = min(beta, eval);
        if (beta &lt;= alpha) {
          break;
        }
      }
      return minEval;
    }
  }

  double evaluate(Board board) {
    double score = 0;
    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = board.squares[i][j];
        if (piece != null) {
          final value = _materialValues[piece.type]!;
          if (piece.color == PieceColor.white) {
            score += value;
          } else {
            score -= value;
          }
        }
      }
    }
    return score;
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_board_dart')">üìÑ lib/src/board.dart</button>
<pre id="lib_src_board_dart" class="file-content" style="display:none;"><code>import 'package:chess_engine/chess_engine.dart';

class Board {
  late List&lt;List&lt;Piece?&gt;&gt; squares;
  late String turn;
  ({int row, int col})? _enPassantTarget;
  String _castlingRights;

  Board._(this.squares, this.turn, this._enPassantTarget, this._castlingRights);

  Board.empty() {
    squares = List.generate(8, (_) =&gt; List.filled(8, null));
    turn = 'w';
    _castlingRights = 'KQkq';
  }

  Board.fromFen(String fen) {
    squares = List.generate(8, (_) =&gt; List.filled(8, null));
    final parts = fen.split(' ');
    final piecePlacement = parts[0];
    turn = parts[1];
    _castlingRights = parts[2];
    // TODO: parse castling rights
    if (parts[3] != '-') {
      _enPassantTarget = _parseSquare(parts[3]);
    } else {
      _enPassantTarget = null;
    }

    int row = 0;
    int col = 0;
    for (final char in piecePlacement.split('')) {
      if (char == '/') {
        row++;
        col = 0;
      } else if (int.tryParse(char) != null) {
        col += int.parse(char);
      } else {
        squares[row][col] = Piece.fromChar(char);
        col++;
      }
    }
  }

  @override
  String toString() {
    final buffer = StringBuffer();
    buffer.writeln('  a b c d e f g h');
    for (int i = 0; i &lt; 8; i++) {
      buffer.write('${8 - i} ');
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        buffer.write('${piece?.toChar() ?? '.'} ');
      }
      buffer.writeln('${8 - i}');
    }
    buffer.writeln('  a b c d e f g h');
    buffer.writeln('');
    buffer.writeln('${turn == 'w' ? 'White' : 'Black'} to move');
    return buffer.toString();
  }

  void move(String moveStr) {
    final from = _parseSquare(moveStr.substring(0, 2));
    final to = _parseSquare(moveStr.substring(2, 4));
    PieceType? promotion;
    if (moveStr.length == 5) {
      promotion = Piece.charToType(moveStr.substring(4, 5).toLowerCase());
    }

    final piece = squares[from.row][from.col]!;

    // Handle castling
    if (piece.type == PieceType.king &amp;&amp; (from.col - to.col).abs() == 2) {
      if (to.col == 6) {
        // Kingside
        final rook = squares[from.row][7];
        squares[from.row][7] = null;
        squares[from.row][5] = rook;
      } else {
        // Queenside
        final rook = squares[from.row][0];
        squares[from.row][0] = null;
        squares[from.row][3] = rook;
      }
    }

    squares[from.row][from.col] = null;

    // En passant capture
    if (piece.type == PieceType.pawn &amp;&amp;
        to.row == _enPassantTarget?.row &amp;&amp;
        to.col == _enPassantTarget?.col) {
      squares[from.row][to.col] = null;
    }

    if (promotion != null) {
      squares[to.row][to.col] = Piece(promotion, piece.color);
    } else {
      squares[to.row][to.col] = piece;
    }

    // Set en passant target
    if (piece.type == PieceType.pawn &amp;&amp; (to.row - from.row).abs() == 2) {
      _enPassantTarget = (row: (from.row + to.row) ~/ 2, col: from.col);
    } else {
      _enPassantTarget = null;
    }

    // Update castling rights
    if (piece.type == PieceType.king) {
      if (piece.color == PieceColor.white) {
        _castlingRights =
            _castlingRights.replaceAll('K', '').replaceAll('Q', '');
      } else {
        _castlingRights =
            _castlingRights.replaceAll('k', '').replaceAll('q', '');
      }
    } else if (piece.type == PieceType.rook) {
      if (from.row == 7 &amp;&amp; from.col == 0 &amp;&amp; piece.color == PieceColor.white) {
        _castlingRights = _castlingRights.replaceAll('Q', '');
      } else if (from.row == 7 &amp;&amp;
          from.col == 7 &amp;&amp;
          piece.color == PieceColor.white) {
        _castlingRights = _castlingRights.replaceAll('K', '');
      } else if (from.row == 0 &amp;&amp;
          from.col == 0 &amp;&amp;
          piece.color == PieceColor.black) {
        _castlingRights = _castlingRights.replaceAll('q', '');
      } else if (from.row == 0 &amp;&amp;
          from.col == 7 &amp;&amp;
          piece.color == PieceColor.black) {
        _castlingRights = _castlingRights.replaceAll('k', '');
      }
    }

    turn = turn == 'w' ? 'b' : 'w';
  }

  ({int row, int col}) _parseSquare(String square) {
    final col = square.codeUnitAt(0) - 'a'.codeUnitAt(0);
    final row = 8 - int.parse(square.substring(1));
    return (row: row, col: col);
  }

  Board clone() {
    final newSquares = List.generate(8, (i) =&gt; List.of(squares[i]));
    return Board._(newSquares, turn, _enPassantTarget, _castlingRights);
  }

  String toFen() {
    final buffer = StringBuffer();
    for (int i = 0; i &lt; 8; i++) {
      int empty = 0;
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece == null) {
          empty++;
        } else {
          if (empty &gt; 0) {
            buffer.write(empty);
            empty = 0;
          }
          buffer.write(piece.toChar());
        }
      }
      if (empty &gt; 0) {
        buffer.write(empty);
      }
      if (i &lt; 7) {
        buffer.write('/');
      }
    }
    buffer.write(' $turn $_castlingRights ');
    if (_enPassantTarget != null) {
      buffer.write(
        '${String.fromCharCode('a'.codeUnitAt(0) + _enPassantTarget!.col)}${8 - _enPassantTarget!.row}',
      );
    } else {
      buffer.write('-');
    }
    buffer.write(' 0 1');
    return buffer.toString();
  }

  List&lt;Move&gt; generateMoves() {
    final pseudoLegalMoves = &lt;Move&gt;[];
    final playerColor = turn == 'w' ? PieceColor.white : PieceColor.black;

    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece != null &amp;&amp; piece.color == playerColor) {
          if (piece.type == PieceType.pawn) {
            _generatePawnMoves(i, j, playerColor, pseudoLegalMoves);
          } else if (piece.type == PieceType.knight) {
            _generateKnightMoves(i, j, playerColor, pseudoLegalMoves);
          } else if (piece.type == PieceType.bishop) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, -1],
              [-1, 1],
              [1, -1],
              [1, 1],
            ]);
          } else if (piece.type == PieceType.rook) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ]);
          } else if (piece.type == PieceType.queen) {
            _generateSlidingMoves(i, j, playerColor, pseudoLegalMoves, [
              [-1, -1],
              [-1, 1],
              [1, -1],
              [1, 1],
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ]);
          } else if (piece.type == PieceType.king) {
            _generateKingMoves(i, j, playerColor, pseudoLegalMoves);
          }
        }
      }
    }

    final legalMoves = &lt;Move&gt;[];
    for (final move in pseudoLegalMoves) {
      final newBoard = clone();
      newBoard.move(move.toString());
      if (!newBoard.isKingInCheck(playerColor)) {
        legalMoves.add(move);
      }
    }

    return legalMoves;
  }

  void _generatePawnMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final direction = color == PieceColor.white ? -1 : 1;
    final startRow = color == PieceColor.white ? 6 : 1;
    final promotionRow = color == PieceColor.white ? 0 : 7;

    // Single move
    if (row + direction &gt;= 0 &amp;&amp;
        row + direction &lt; 8 &amp;&amp;
        squares[row + direction][col] == null) {
      if (row + direction == promotionRow) {
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.queen),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.rook),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.bishop),
        );
        moves.add(
          Move(row, col, row + direction, col, promotion: PieceType.knight),
        );
      } else {
        moves.add(Move(row, col, row + direction, col));
      }

      // Double move
      if (row == startRow &amp;&amp; squares[row + 2 * direction][col] == null) {
        moves.add(Move(row, col, row + 2 * direction, col));
      }
    }

    // Captures
    for (int dcol = -1; dcol &lt;= 1; dcol += 2) {
      if (col + dcol &gt;= 0 &amp;&amp; col + dcol &lt; 8) {
        if (row + direction &gt;= 0 &amp;&amp; row + direction &lt; 8) {
          final dest = squares[row + direction][col + dcol];
          if (dest != null &amp;&amp; dest.color != color) {
            if (row + direction == promotionRow) {
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.queen,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.rook,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.bishop,
                ),
              );
              moves.add(
                Move(
                  row,
                  col,
                  row + direction,
                  col + dcol,
                  promotion: PieceType.knight,
                ),
              );
            } else {
              moves.add(Move(row, col, row + direction, col + dcol));
            }
          } else if (_enPassantTarget != null &amp;&amp;
              _enPassantTarget!.row == row + direction &amp;&amp;
              _enPassantTarget!.col == col + dcol) {
            moves.add(Move(row, col, row + direction, col + dcol));
          }
        }
      }
    }
  }

  void _generateKnightMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final offsets = [
      [-2, -1],
      [-2, 1],
      [-1, -2],
      [-1, 2],
      [1, -2],
      [1, 2],
      [2, -1],
      [2, 1],
    ];
    for (final offset in offsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final dest = squares[newRow][newCol];
        if (dest == null || dest.color != color) {
          moves.add(Move(row, col, newRow, newCol));
        }
      }
    }
  }

  void _generateSlidingMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
    List&lt;List&lt;int&gt;&gt; directions,
  ) {
    for (final dir in directions) {
      for (int i = 1; i &lt; 8; i++) {
        final newRow = row + i * dir[0];
        final newCol = col + i * dir[1];
        if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
          final dest = squares[newRow][newCol];
          if (dest == null) {
            moves.add(Move(row, col, newRow, newCol));
          } else {
            if (dest.color != color) {
              moves.add(Move(row, col, newRow, newCol));
            }
            break;
          }
        } else {
          break;
        }
      }
    }
  }

  void _generateKingMoves(
    int row,
    int col,
    PieceColor color,
    List&lt;Move&gt; moves,
  ) {
    final offsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ];
    for (final offset in offsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final dest = squares[newRow][newCol];
        if (dest == null || dest.color != color) {
          moves.add(Move(row, col, newRow, newCol));
        }
      }
    }

    // Castling
    if (color == PieceColor.white) {
      if (_castlingRights.contains('K') &amp;&amp;
          squares[7][5] == null &amp;&amp;
          squares[7][6] == null) {
        moves.add(Move(7, 4, 7, 6));
      }
      if (_castlingRights.contains('Q') &amp;&amp;
          squares[7][1] == null &amp;&amp;
          squares[7][2] == null &amp;&amp;
          squares[7][3] == null) {
        moves.add(Move(7, 4, 7, 2));
      }
    } else {
      if (_castlingRights.contains('k') &amp;&amp;
          squares[0][5] == null &amp;&amp;
          squares[0][6] == null) {
        moves.add(Move(0, 4, 0, 6));
      }
      if (_castlingRights.contains('q') &amp;&amp;
          squares[0][1] == null &amp;&amp;
          squares[0][2] == null &amp;&amp;
          squares[0][3] == null) {
        moves.add(Move(0, 4, 0, 2));
      }
    }
  }

  int perft(int depth) {
    if (depth == 0) {
      return 1;
    }

    int nodes = 0;
    final moves = generateMoves();
    for (final move in moves) {
      final newBoard = clone();
      newBoard.move(move.toString());
      nodes += newBoard.perft(depth - 1);
    }
    return nodes;
  }

  bool isSquareAttacked(int row, int col, PieceColor attackerColor) {
    // Check for pawn attacks
    final direction = attackerColor == PieceColor.white ? -1 : 1;
    if (row + direction &gt;= 0 &amp;&amp; row + direction &lt; 8) {
      if (col - 1 &gt;= 0) {
        final piece = squares[row + direction][col - 1];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.pawn) {
          return true;
        }
      }
      if (col + 1 &lt; 8) {
        final piece = squares[row + direction][col + 1];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.pawn) {
          return true;
        }
      }
    }

    // Check for knight attacks
    final knightOffsets = [
      [-2, -1],
      [-2, 1],
      [-1, -2],
      [-1, 2],
      [1, -2],
      [1, 2],
      [2, -1],
      [2, 1],
    ];
    for (final offset in knightOffsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final piece = squares[newRow][newCol];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.knight) {
          return true;
        }
      }
    }

    // Check for sliding attacks (rooks, bishops, queens)
    final slidingDirections = {
      PieceType.rook: [
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1],
      ],
      PieceType.bishop: [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1],
      ],
      PieceType.queen: [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1],
      ],
    };

    for (final pieceType in slidingDirections.keys) {
      for (final dir in slidingDirections[pieceType]!) {
        for (int i = 1; i &lt; 8; i++) {
          final newRow = row + i * dir[0];
          final newCol = col + i * dir[1];
          if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
            final piece = squares[newRow][newCol];
            if (piece != null) {
              if (piece.color == attackerColor &amp;&amp;
                  (piece.type == pieceType || piece.type == PieceType.queen)) {
                return true;
              }
              break;
            }
          } else {
            break;
          }
        }
      }
    }

    // Check for king attacks
    final kingOffsets = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ];
    for (final offset in kingOffsets) {
      final newRow = row + offset[0];
      final newCol = col + offset[1];
      if (newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
        final piece = squares[newRow][newCol];
        if (piece != null &amp;&amp;
            piece.color == attackerColor &amp;&amp;
            piece.type == PieceType.king) {
          return true;
        }
      }
    }

    return false;
  }

  bool isKingInCheck(PieceColor kingColor) {
    int kingRow = -1;
    int kingCol = -1;
    for (int i = 0; i &lt; 8; i++) {
      for (int j = 0; j &lt; 8; j++) {
        final piece = squares[i][j];
        if (piece != null &amp;&amp;
            piece.type == PieceType.king &amp;&amp;
            piece.color == kingColor) {
          kingRow = i;
          kingCol = j;
          break;
        }
      }
    }
    return isSquareAttacked(
      kingRow,
      kingCol,
      kingColor == PieceColor.white ? PieceColor.black : PieceColor.white,
    );
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_game_dart')">üìÑ lib/src/game.dart</button>
<pre id="lib_src_game_dart" class="file-content" style="display:none;"><code>import 'package:collection/collection.dart';
import 'package:chess_engine/chess_engine.dart';

class Game {
  late List&lt;Board&gt; history;

  Game() {
    init();
  }

  void init() {
    history = [Board.fromFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')];
  }

  Board get board =&gt; history.last;

  void printBoard() {
    print(board.toString());
  }

  void move(String moveStr) {
    final legalMoves = board.generateMoves();
    final move = legalMoves.firstWhereOrNull((m) =&gt; m.toString() == moveStr);

    if (move == null) {
      throw Exception('ERROR: Illegal move');
    }

    final newBoard = board.clone();
    newBoard.move(move.toString());
    history.add(newBoard);
  }

  void undo() {
    if (history.length &gt; 1) {
      history.removeLast();
    }
  }

  void loadFen(String fen) {
    history = [Board.fromFen(fen)];
  }

  void export() {
    print('FEN: ${board.toFen()}');
  }

  void perft(int depth) {
    final count = board.perft(depth);
    print('Perft $depth: $count');
  }

  GameState getGameState() {
    final legalMoves = board.generateMoves();
    if (legalMoves.isNotEmpty) {
      return GameState.inProgress;
    }

    final playerColor = board.turn == 'w' ? PieceColor.white : PieceColor.black;
    if (board.isKingInCheck(playerColor)) {
      return playerColor == PieceColor.white ? GameState.checkmateBlackWins : GameState.checkmateWhiteWins;
    } else {
      return GameState.stalemate;
    }
  }
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_game_state_dart')">üìÑ lib/src/game_state.dart</button>
<pre id="lib_src_game_state_dart" class="file-content" style="display:none;"><code>enum GameState { inProgress, checkmateWhiteWins, checkmateBlackWins, stalemate }
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_move_dart')">üìÑ lib/src/move.dart</button>
<pre id="lib_src_move_dart" class="file-content" style="display:none;"><code>import 'package:chess_engine/chess_engine.dart';

class Move {
  final int fromRow;
  final int fromCol;
  final int toRow;
  final int toCol;
  final PieceType? promotion;

  Move(this.fromRow, this.fromCol, this.toRow, this.toCol, {this.promotion});

  @override
  String toString() {
    return '${_colToChar(fromCol)}${8 - fromRow}${_colToChar(toCol)}${8 - toRow}${promotion != null ? _typeToChar(promotion!) : ''}';
  }

  static String _colToChar(int col) {
    return String.fromCharCode('a'.codeUnitAt(0) + col);
  }

  static String _typeToChar(PieceType type) {
    switch (type) {
      case PieceType.queen:
        return 'q';
      case PieceType.rook:
        return 'r';
      case PieceType.bishop:
        return 'b';
      case PieceType.knight:
        return 'n';
      default:
        return '';
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('lib_src_piece_dart')">üìÑ lib/src/piece.dart</button>
<pre id="lib_src_piece_dart" class="file-content" style="display:none;"><code>enum PieceType { king, queen, rook, bishop, knight, pawn }

enum PieceColor { white, black }

class Piece {
  final PieceType type;
  final PieceColor color;

  Piece(this.type, this.color);

  factory Piece.fromChar(String char) {
    final color =
        char.toUpperCase() == char ? PieceColor.white : PieceColor.black;
    final type = charToType(char.toLowerCase());
    return Piece(type, color);
  }

  String toChar() {
    final char = _typeToChar(type);
    return color == PieceColor.white ? char.toUpperCase() : char.toLowerCase();
  }

  static PieceType charToType(String char) {
    switch (char) {
      case 'k':
        return PieceType.king;
      case 'q':
        return PieceType.queen;
      case 'r':
        return PieceType.rook;
      case 'b':
        return PieceType.bishop;
      case 'n':
        return PieceType.knight;
      case 'p':
        return PieceType.pawn;
      default:
        throw ArgumentError('Invalid piece character: $char');
    }
  }

  static String _typeToChar(PieceType type) {
    switch (type) {
      case PieceType.king:
        return 'k';
      case PieceType.queen:
        return 'q';
      case PieceType.rook:
        return 'r';
      case PieceType.bishop:
        return 'b';
      case PieceType.knight:
        return 'n';
      case PieceType.pawn:
        return 'p';
    }
  }
}
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('pubspec_lock')">üìÑ pubspec.lock</button>
<pre id="pubspec_lock" class="file-content" style="display:none;"><code># Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  collection:
    dependency: "direct main"
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
sdks:
  dart: "&gt;=3.4.0 &lt;4.0.0"
</code></pre>
</div>
<div class="file-item">
<button class="file-toggle" onclick="toggleFile('pubspec_yaml')">üìÑ pubspec.yaml</button>
<pre id="pubspec_yaml" class="file-content" style="display:none;"><code>name: chess_engine
description: A command-line chess engine.
version: 1.0.0
environment:
  sdk: '&gt;=3.0.0 &lt;4.0.0'
dependencies:
  collection: ^1.18.0
</code></pre>
</div>
</div>

<script>
function toggleFile(id) {
    var content = document.getElementById(id);
    if (content.style.display === 'none') {
        content.style.display = 'block';
    } else {
        content.style.display = 'none';
    }
}
</script>

    </main>
    <footer>
        <p>Generated from benchmark data. All implementations tested via Docker for consistency.</p>
        <p><a href="https://github.com/evaisse/the-great-analysis-challenge">View on GitHub</a></p>
    </footer>
</body>
</html>
