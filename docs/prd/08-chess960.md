# PRD-08 : Framework Chess960 (Fischer Random Chess)

## Résumé

Implémenter le support de Chess960 (Fischer Random Chess), une variante où la position de départ des pièces sur la première rangée est aléatoire parmi 960 configurations valides. Cela nécessite un refactoring significatif de la logique de roque, du parseur FEN, et de la génération de coups.

## Métriques cibles

| Indicateur | Valeur |
|---|---|
| LOC ajoutées par langage | +600 – 1 600 |
| LOC totales ajoutées (×7) | ~4 200 – 11 200 |
| Priorité | **P3 — Bonus** |

## Pertinence pour le projet

### Valeur fonctionnelle (moteur d'échecs)

Chess960 est officiellement reconnu par la FIDE depuis 2019 et gagne en popularité sur les plateformes en ligne (Lichess, Chess.com). Le support Chess960 :

- **Teste la robustesse** : un moteur qui gère Chess960 prouve que sa logique de roque n'est pas codée en dur pour e1g1/e1c1 mais est véritablement générique
- **960 positions de départ** : au lieu d'une seule, permettant des tests de perft sur des configurations variées
- **FEN étendu** : le FEN Chess960 utilise des lettres (A-H / a-h) pour les droits de roque au lieu de KQkq, ce qui complexifie le parseur
- **Roque généralisé** : le roi et la tour arrivent sur les mêmes cases finales (g1/f1 ou c1/d1) mais partent de cases arbitraires

### Valeur pour l'objectif du projet (stress des toolchains)

Chess960 force un **refactoring en profondeur** de code existant, ce qui est le cas le plus stressant pour les analyseurs statiques (ils doivent re-vérifier tout le code modifié) :

| Langage | Ce que ça stress | Détail |
|---|---|---|
| **Rust** | Refactoring, generics, pattern matching | Le roque actuel est probablement un `match` sur 4 cas (e1g1, e1c1, e8g8, e8c8). Chess960 nécessite un roque paramétré par les positions roi/tour → `CastlingConfig<KingFile, RookFile>`. Le compilateur doit re-vérifier tous les call sites |
| **TypeScript** | Refactoring types, conditional types | Le type `CastlingRight` passe de `'K' | 'Q' | 'k' | 'q'` à `{ king_file: File, rook_file: File, side: 'king' | 'queen' }` — tous les endroits qui utilisaient le type simple doivent être mis à jour. `tsc` doit re-vérifier |
| **Python** | `mypy` refactoring, `dataclass` | Le `@dataclass CastlingRights` change de structure → `mypy` doit re-analyser tous les fichiers qui l'importent. Plus de variantes dans les `match` statements |
| **PHP** | PHPStan impact analysis | Changement d'interface `CastlingRights` → PHPStan doit re-analyser tous les fichiers dépendants. Plus d'assertions de type |
| **Dart** | Sealed classes, exhaustiveness | Plus de variantes dans les `sealed class`es de roque → l'analyseur doit vérifier que tous les `switch` sont mis à jour |
| **Ruby** | Complexité, Steep | Le roque Chess960 a beaucoup de cas limites (roi et tour échangent, roi ne bouge pas mais tour oui...) → haute complexité cyclomatique |
| **Lua** | Tables imbriquées, conditions | Logique de roque plus complexe avec plus de conditions → LuaCheck détecte les branches non couvertes |

**Point clé** : Chess960 ne peut pas être "ajouté à côté" — il **modifie** le code de roque existant, ce qui force les analyseurs à re-vérifier du code déjà stable. C'est le type de changement le plus coûteux en analyse statique.

## Description fonctionnelle

### 1. Positions de départ Chess960

#### Règles de placement

La première rangée doit respecter :
1. Le roi est entre les deux tours
2. Les deux fous sont sur des cases de couleurs opposées
3. Les pièces noires mirrorent les blanches

#### Numérotation (Scharnagl)

Chaque position a un numéro unique de 0 à 959. L'algorithme de décodage :

```pseudocode
function generate_position(number):
    pieces = [_, _, _, _, _, _, _, _]  // 8 cases
    
    // Étape 1 : Placer le fou case noire
    n1, remainder = divmod(number, 4)
    pieces[2 * remainder + 1] = BISHOP
    
    // Étape 2 : Placer le fou case blanche
    n2, remainder = divmod(n1, 4)
    pieces[2 * remainder] = BISHOP
    
    // Étape 3 : Placer la dame
    n3, remainder = divmod(n2, 6)
    empty = get_empty_squares(pieces)
    pieces[empty[remainder]] = QUEEN
    
    // Étape 4 : Placer les cavaliers (table de Scharnagl)
    knight_table = [(0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]
    k1, k2 = knight_table[n3]
    empty = get_empty_squares(pieces)
    pieces[empty[k1]] = KNIGHT
    pieces[empty[k2]] = KNIGHT
    
    // Étape 5 : Placer Tour-Roi-Tour dans les 3 cases restantes
    empty = get_empty_squares(pieces)
    pieces[empty[0]] = ROOK
    pieces[empty[1]] = KING
    pieces[empty[2]] = ROOK
    
    return pieces
```

### 2. Roque Chess960

#### Règle fondamentale

En Chess960, le roque place toujours le roi et la tour sur les **mêmes cases finales** que dans les échecs classiques :

| Roque | Roi → | Tour → |
|---|---|---|
| Kingside (blanc) | g1 | f1 |
| Queenside (blanc) | c1 | d1 |
| Kingside (noir) | g8 | f8 |
| Queenside (noir) | c8 | d8 |

Mais le roi et la tour partent de cases arbitraires. Cela crée des cas spéciaux :

- Le roi peut ne pas bouger (s'il est déjà sur g1/c1)
- La tour peut ne pas bouger (si elle est déjà sur f1/d1)
- Le roi et la tour peuvent "échanger" leurs cases
- Le roi peut traverser la position de la tour

#### Conditions de roque (généralisées)

```pseudocode
function can_castle(position, king_square, rook_square, target_king, target_rook):
    // 1. Ni le roi ni la tour n'ont bougé
    if king_has_moved or rook_has_moved:
        return false
    
    // 2. Le roi n'est pas en échec
    if is_in_check(position):
        return false
    
    // 3. Toutes les cases entre les positions actuelles et cibles sont vides
    //    (sauf les cases occupées par le roi et la tour qui bougent)
    for square in path(king_square, target_king) + path(rook_square, target_rook):
        if square != king_square and square != rook_square:
            if not is_empty(position, square):
                return false
    
    // 4. Le roi ne traverse pas de case attaquée
    for square in path(king_square, target_king):
        if is_attacked(position, square, opponent):
            return false
    
    return true
```

### 3. FEN Chess960

En Chess960, les droits de roque utilisent les lettres des colonnes des tours :

```
// Classique
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1

// Chess960 (position 518 = classique)
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w AHah - 0 1

// Chess960 (position 534)
rkbqnbnr/pppppppp/8/8/8/8/PPPPPPPP/RKBQNBNR w ABab - 0 1
// A = tour en colonne a, B = tour en colonne b (pour les blancs)
```

Le parseur FEN doit supporter les deux notations.

### 4. Configuration de roque

```
CastlingConfig {
  white_king_file: File        // Colonne du roi blanc (peut être a-h)
  white_kingside_rook: File    // Colonne de la tour kingside blanche
  white_queenside_rook: File   // Colonne de la tour queenside blanche
  black_king_file: File        // Idem pour les noirs
  black_kingside_rook: File
  black_queenside_rook: File
}
```

### 5. Commandes CLI

```
new960           -- Nouvelle partie Chess960 (position aléatoire)
new960 <n>       -- Nouvelle partie Chess960 (position n, 0-959)
position960      -- Afficher le numéro de la position courante
```

## Fichiers à créer/modifier par langage

```
<lang>/
├── src/
│   ├── chess960/
│   │   ├── mod.{ext}              -- Module principal
│   │   ├── position_generator.{ext} -- Générateur des 960 positions
│   │   ├── castling_config.{ext}  -- Configuration de roque généralisée
│   │   └── scharnagl.{ext}       -- Encodage/décodage Scharnagl
│   ├── castling.{ext}             -- MODIFIÉ : roque généralisé
│   ├── fen.{ext}                  -- MODIFIÉ : support FEN Chess960
│   └── move_generator.{ext}      -- MODIFIÉ : roque depuis positions variables
```

**Note** : cette feature **modifie** des fichiers existants en plus d'en créer de nouveaux, ce qui maximise l'impact sur l'analyse incrémentale.

## Dépendances

- **Aucun prérequis** : peut être implémenté indépendamment
- **Interaction avec** PRD-07 (Zobrist) : les clés de roque doivent être adaptées pour Chess960

## Tests de validation

1. **960 positions** : les 960 configurations sont valides (roi entre les tours, fous sur cases de couleurs opposées)
2. **Scharnagl** : encode(decode(n)) == n pour n ∈ [0, 959]
3. **Position 518** : correspond aux échecs classiques
4. **Roque Chess960** : tester les cas limites (roi immobile, tour immobile, échange)
5. **FEN Chess960** : import/export avec notation par colonnes
6. **Perft Chess960** : valeurs de référence pour des positions Chess960 connues
7. **Rétrocompatibilité** : les échecs classiques fonctionnent toujours

## Critères de succès

- [ ] Générateur des 960 positions fonctionnel
- [ ] Roque généralisé (fonctionne pour classique ET Chess960)
- [ ] FEN Chess960 supporté (notation par colonnes)
- [ ] Au moins 5 cas limites de roque testés
- [ ] Perft sur au moins 3 positions Chess960
- [ ] Les tests classiques passent toujours
- [ ] Temps de build mesurés avant/après (impact du refactoring)
