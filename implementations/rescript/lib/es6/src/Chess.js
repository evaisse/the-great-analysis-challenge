// Generated by ReScript, PLEASE EDIT WITH CARE

import * as AI from "./AI.js";
import * as Board from "./Board.js";
import * as Perft from "./Perft.js";
import * as Utils from "./Utils.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Readline from "readline";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Evaluation from "./Evaluation.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as DrawDetection from "./DrawDetection.js";
import * as MoveGenerator from "./MoveGenerator.js";

function createEngine() {
  return {
          state: Board.createInitialState(),
          history: []
        };
}

function parseMove(moveStr) {
  var len = moveStr.length;
  if (len < 4 || len > 5) {
    return ;
  }
  var fromStr = Js_string.substring(0, 2, moveStr);
  var toStr = Js_string.substring(2, 4, moveStr);
  var match = Utils.parseSquare(fromStr);
  var match$1 = Utils.parseSquare(toStr);
  if (match === undefined) {
    return ;
  }
  if (match$1 === undefined) {
    return ;
  }
  var promotion;
  if (len === 5) {
    var match$2 = Js_string.charAt(4, moveStr).toLowerCase();
    switch (match$2) {
      case "b" :
          promotion = "Bishop";
          break;
      case "n" :
          promotion = "Knight";
          break;
      case "q" :
          promotion = "Queen";
          break;
      case "r" :
          promotion = "Rook";
          break;
      default:
        promotion = undefined;
    }
  } else {
    promotion = undefined;
  }
  return [
          match,
          match$1,
          promotion
        ];
}

function executeMove(engine, moveStr) {
  var match = parseMove(moveStr);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "Invalid move format"
          };
  }
  var promotion = match[2];
  var to = match[1];
  var from = match[0];
  var piece = Caml_array.get(engine.state.board, from);
  if (piece === undefined) {
    return {
            TAG: "Error",
            _0: "No piece at source square"
          };
  }
  if (piece.color !== engine.state.turn) {
    return {
            TAG: "Error",
            _0: "Wrong color piece"
          };
  }
  var legalMoves = MoveGenerator.generateLegalMoves(engine.state);
  var matchingMove = Belt_Array.getBy(legalMoves, (function (move) {
          if (move.from === from && move.to === to) {
            if (promotion === undefined) {
              return true;
            } else {
              return Caml_obj.equal(move.promotion, promotion);
            }
          } else {
            return false;
          }
        }));
  if (matchingMove !== undefined) {
    engine.history = Belt_Array.concat(engine.history, [engine.state]);
    engine.state = MoveGenerator.makeMove(engine.state, matchingMove);
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "Illegal move"
          };
  }
}

function undoMove(engine) {
  var len = engine.history.length;
  if (len > 0) {
    engine.state = Caml_array.get(engine.history, len - 1 | 0);
    engine.history = Belt_Array.slice(engine.history, 0, len - 1 | 0);
    return true;
  } else {
    return false;
  }
}

function checkGameStatus(state) {
  var legalMoves = MoveGenerator.generateLegalMoves(state);
  if (legalMoves.length === 0) {
    if (MoveGenerator.isKingInCheck(state, state.turn)) {
      return {
              TAG: "Checkmate",
              _0: Utils.oppositeColor(state.turn)
            };
    } else {
      return "Stalemate";
    }
  } else if (DrawDetection.isDraw(state)) {
    return "Stalemate";
  } else {
    return "InProgress";
  }
}

function processCommand(engine, input) {
  var parts = Js_string.split(" ", input.trim());
  if (parts.length !== 0) {
    var match = Caml_array.get(parts, 0);
    switch (match) {
      case "ai" :
          var depth = parts.length > 1 ? Belt_Option.getWithDefault(Belt_Int.fromString(Caml_array.get(parts, 1)), 3) : 3;
          if (depth < 1 || depth > 5) {
            console.log("ERROR: AI depth must be 1-5");
          } else {
            var startTime = Date.now();
            var match$1 = AI.findBestMove(engine.state, depth);
            if (match$1 !== undefined) {
              var move = match$1[0];
              var moveStr = Utils.squareToString(move.from) + Utils.squareToString(move.to);
              var match$2 = move.promotion;
              var moveStrWithPromo;
              if (match$2 !== undefined) {
                switch (match$2) {
                  case "Knight" :
                      moveStrWithPromo = moveStr + "n";
                      break;
                  case "Bishop" :
                      moveStrWithPromo = moveStr + "b";
                      break;
                  case "Rook" :
                      moveStrWithPromo = moveStr + "r";
                      break;
                  case "Queen" :
                      moveStrWithPromo = moveStr + "q";
                      break;
                  case "Pawn" :
                  case "King" :
                      moveStrWithPromo = moveStr;
                      break;
                  
                }
              } else {
                moveStrWithPromo = moveStr;
              }
              engine.history = Belt_Array.concat(engine.history, [engine.state]);
              engine.state = MoveGenerator.makeMove(engine.state, move);
              var endTime = Date.now();
              var timeMs = endTime - startTime | 0;
              console.log("AI: " + moveStrWithPromo + " (depth=" + String(depth) + ", eval=" + String(match$1[1]) + ", time=" + String(timeMs) + ")");
              var winner = checkGameStatus(engine.state);
              if (typeof winner !== "object") {
                if (winner !== "InProgress") {
                  console.log("STALEMATE: Draw");
                }
                
              } else {
                var winnerStr = winner._0 === "White" ? "White" : "Black";
                console.log("CHECKMATE: " + winnerStr + " wins");
              }
            } else {
              console.log("ERROR: No legal moves available");
            }
          }
          break;
      case "draws" :
          var repetition = DrawDetection.isDrawByRepetition(engine.state);
          var fiftyMoves = DrawDetection.isDrawByFiftyMoves(engine.state);
          console.log("Repetition: " + (
                repetition ? "true" : "false"
              ) + ", 50-move rule: " + (
                fiftyMoves ? "true" : "false"
              ) + ", 50-move clock: " + String(engine.state.halfmoveClock));
          break;
      case "eval" :
          var score = Evaluation.evaluateGameState(engine.state);
          console.log("Evaluation: " + String(score));
          break;
      case "export" :
          var fen = Board.exportFen(engine.state);
          console.log("FEN: " + fen);
          break;
      case "fen" :
          if (parts.length < 2) {
            console.log("ERROR: Invalid FEN command");
          } else {
            var fenParts = Belt_Array.sliceToEnd(parts, 1);
            var fenStr = Belt_Array.reduce(fenParts, "", (function (acc, item) {
                    if (acc === "") {
                      return item;
                    } else {
                      return acc + " " + item;
                    }
                  }));
            var newState = Board.parseFen(fenStr);
            if (newState.TAG === "Ok") {
              engine.state = newState._0;
              engine.history = [];
              console.log("OK: Position loaded");
            } else {
              console.log("ERROR: " + newState._0);
            }
          }
          break;
      case "hash" :
          console.log("Hash: " + (((h) => h.toString(16).padStart(16, "0")))(engine.state.zobristHash));
          break;
      case "help" :
          console.log("Available commands:");
          console.log("  move <from><to>[promotion] - Make a move (e.g., e2e4, e7e8Q)");
          console.log("  undo - Undo the last move");
          console.log("  new - Start a new game");
          console.log("  ai <depth> - Let AI make a move (depth 1-5)");
          console.log("  fen <string> - Load position from FEN");
          console.log("  export - Export current position as FEN");
          console.log("  eval - Display position evaluation");
          console.log("  perft <depth> - Run performance test");
          console.log("  help - Display this help message");
          console.log("  quit - Exit the program");
          break;
      case "history" :
          var historyLen = engine.state.positionHistory.length;
          console.log("Position History (" + String(historyLen + 1 | 0) + " positions):");
          Belt_Array.forEachWithIndex(engine.state.positionHistory, (function (i, h) {
                  console.log("  " + String(i) + ": " + h.toString());
                }));
          console.log("  " + String(historyLen) + ": " + engine.state.zobristHash.toString() + " (current)");
          break;
      case "move" :
          if (parts.length < 2) {
            console.log("ERROR: Invalid command");
          } else {
            var msg = executeMove(engine, Caml_array.get(parts, 1));
            if (msg.TAG === "Ok") {
              console.log("OK: " + Caml_array.get(parts, 1));
              var winner$1 = checkGameStatus(engine.state);
              if (typeof winner$1 !== "object") {
                if (winner$1 !== "InProgress") {
                  console.log("STALEMATE: Draw");
                }
                
              } else {
                var winnerStr$1 = winner$1._0 === "White" ? "White" : "Black";
                console.log("CHECKMATE: " + winnerStr$1 + " wins");
              }
            } else {
              console.log("ERROR: " + msg._0);
            }
          }
          break;
      case "new" :
          engine.state = Board.createInitialState();
          engine.history = [];
          console.log("OK: New game started");
          break;
      case "perft" :
          if (parts.length < 2) {
            console.log("ERROR: Invalid perft command");
          } else {
            var depth$1 = Belt_Int.fromString(Caml_array.get(parts, 1));
            if (depth$1 !== undefined) {
              if (depth$1 < 1 || depth$1 > 6) {
                console.log("ERROR: Depth must be 1-6");
              } else {
                var startTime$1 = Date.now();
                var count = Perft.perft(engine.state, depth$1);
                var endTime$1 = Date.now();
                var timeMs$1 = endTime$1 - startTime$1 | 0;
                console.log("Perft(" + String(depth$1) + "): " + String(count) + " nodes in " + String(timeMs$1) + "ms");
              }
            } else {
              console.log("ERROR: Invalid depth");
            }
          }
          break;
      case "quit" :
          process.exit(0);
          break;
      case "undo" :
          if (undoMove(engine)) {
            console.log("OK: Move undone");
          } else {
            console.log("ERROR: No moves to undo");
          }
          break;
      default:
        console.log("ERROR: Invalid command. Type 'help' for available commands.");
    }
  }
  if (Caml_array.get(parts, 0) !== "help" && Caml_array.get(parts, 0) !== "quit") {
    console.log("");
    console.log(Board.boardToString(engine.state));
    return ;
  }
  
}

function main() {
  var engine = createEngine();
  console.log("Chess Engine - ReScript Implementation");
  console.log("Type 'help' for available commands");
  console.log("");
  console.log(Board.boardToString(engine.state));
  var readline = Readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        prompt: "> "
      });
  readline.prompt();
  readline.on("line", (function (line) {
          processCommand(engine, line);
          readline.prompt();
        }));
  readline.on("close", (function () {
          console.log("\nGoodbye!");
          process.exit(0);
        }));
}

main();

export {
  createEngine ,
  parseMove ,
  executeMove ,
  undoMove ,
  checkGameStatus ,
  processCommand ,
  main ,
}
/*  Not a pure module */
