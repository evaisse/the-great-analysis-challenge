// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";

function xor(a, b) {
  return (((a, b) => a ^ b))(a, b);
}

function shiftL(a, b) {
  return (((a, b) => a << b))(a, b);
}

function shiftR(a, b) {
  return (((a, b) => a >> b))(a, b);
}

function bitAnd(a, b) {
  return (((a, b) => a & b))(a, b);
}

var mask64 = 0xFFFFFFFFFFFFFFFFn;

function xorshift64(state) {
  var s = state;
  s = xor(s, bitAnd(shiftL(s, 13n), mask64));
  s = xor(s, shiftR(s, 7n));
  s = xor(s, bitAnd(shiftL(s, 17n), mask64));
  return s;
}

function generateKeys() {
  var state = {
    contents: 0x123456789ABCDEF0n
  };
  var next = function () {
    state.contents = xorshift64(state.contents);
    return state.contents;
  };
  var pieces = Caml_array.make(12, []);
  for(var i = 0; i <= 11; ++i){
    var pieceKeys = Caml_array.make(64, 0n);
    for(var j = 0; j <= 63; ++j){
      Caml_array.set(pieceKeys, j, next());
    }
    Caml_array.set(pieces, i, pieceKeys);
  }
  var sideToMove = next();
  var castling = Caml_array.make(4, 0n);
  for(var i$1 = 0; i$1 <= 3; ++i$1){
    Caml_array.set(castling, i$1, next());
  }
  var enPassant = Caml_array.make(8, 0n);
  for(var i$2 = 0; i$2 <= 7; ++i$2){
    Caml_array.set(enPassant, i$2, next());
  }
  return {
          pieces: pieces,
          sideToMove: sideToMove,
          castling: castling,
          enPassant: enPassant
        };
}

var globalKeys = generateKeys();

function getPieceIndex(piece) {
  var match = piece.pieceType;
  var typeIdx;
  switch (match) {
    case "Pawn" :
        typeIdx = 0;
        break;
    case "Knight" :
        typeIdx = 1;
        break;
    case "Bishop" :
        typeIdx = 2;
        break;
    case "Rook" :
        typeIdx = 3;
        break;
    case "Queen" :
        typeIdx = 4;
        break;
    case "King" :
        typeIdx = 5;
        break;
    
  }
  if (piece.color === "White") {
    return typeIdx;
  } else {
    return typeIdx + 6 | 0;
  }
}

function computeHash(state) {
  var hash = 0n;
  for(var i = 0; i <= 63; ++i){
    var piece = Caml_array.get(state.board, i);
    if (piece !== undefined) {
      var idx = getPieceIndex(piece);
      hash = xor(hash, Caml_array.get(Caml_array.get(globalKeys.pieces, idx), i));
    }
    
  }
  if (state.turn === "Black") {
    hash = xor(hash, globalKeys.sideToMove);
  }
  if (state.castlingRights.whiteKingside) {
    hash = xor(hash, Caml_array.get(globalKeys.castling, 0));
  }
  if (state.castlingRights.whiteQueenside) {
    hash = xor(hash, Caml_array.get(globalKeys.castling, 1));
  }
  if (state.castlingRights.blackKingside) {
    hash = xor(hash, Caml_array.get(globalKeys.castling, 2));
  }
  if (state.castlingRights.blackQueenside) {
    hash = xor(hash, Caml_array.get(globalKeys.castling, 3));
  }
  var sq = state.enPassantTarget;
  if (sq !== undefined) {
    hash = xor(hash, Caml_array.get(globalKeys.enPassant, Utils.modInt(sq, 8)));
  }
  return hash;
}

export {
  xor ,
  shiftL ,
  shiftR ,
  bitAnd ,
  mask64 ,
  xorshift64 ,
  generateKeys ,
  globalKeys ,
  getPieceIndex ,
  computeHash ,
}
/* globalKeys Not a pure module */
