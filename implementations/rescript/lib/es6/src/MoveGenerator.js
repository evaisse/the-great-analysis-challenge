// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Types from "./Types.js";
import * as Utils from "./Utils.js";
import * as Zobrist from "./Zobrist.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function isValidSquare(square) {
  if (square >= 0) {
    return square < 64;
  } else {
    return false;
  }
}

function getPiece(state, square) {
  if (isValidSquare(square)) {
    return Belt_Array.getExn(state.board, square);
  }
  
}

function generatePawnMoves(state, from, piece) {
  var moves = [];
  var direction = piece.color === "White" ? 8 : -8;
  var startRank = piece.color === "White" ? 1 : 6;
  var promotionRank = piece.color === "White" ? 7 : 0;
  var rank = from / 8 | 0;
  var file = Utils.modInt(from, 8);
  var oneSquareForward = from + direction | 0;
  if (isValidSquare(oneSquareForward) && getPiece(state, oneSquareForward) === undefined) {
    if ((oneSquareForward / 8 | 0) === promotionRank) {
      Belt_Array.forEach(Types.promotionPieces, (function (promo) {
              moves.push({
                    from: from,
                    to: oneSquareForward,
                    piece: "Pawn",
                    captured: undefined,
                    promotion: promo,
                    castling: undefined,
                    enPassant: false
                  });
            }));
    } else {
      moves.push({
            from: from,
            to: oneSquareForward,
            piece: "Pawn",
            captured: undefined,
            promotion: undefined,
            castling: undefined,
            enPassant: false
          });
    }
    if (rank === startRank) {
      var twoSquaresForward = from + (direction << 1) | 0;
      if (getPiece(state, twoSquaresForward) === undefined) {
        moves.push({
              from: from,
              to: twoSquaresForward,
              piece: "Pawn",
              captured: undefined,
              promotion: undefined,
              castling: undefined,
              enPassant: false
            });
      }
      
    }
    
  }
  var captureOffsets = [
    direction - 1 | 0,
    direction + 1 | 0
  ];
  Belt_Array.forEach(captureOffsets, (function (offset) {
          var to = from + offset | 0;
          var toFile = Utils.modInt(to, 8);
          if (!(isValidSquare(to) && Utils.absInt(toFile - file | 0) === 1)) {
            return ;
          }
          var target = getPiece(state, to);
          if (target !== undefined && target.color !== piece.color) {
            if ((to / 8 | 0) === promotionRank) {
              return Belt_Array.forEach(Types.promotionPieces, (function (promo) {
                            moves.push({
                                  from: from,
                                  to: to,
                                  piece: "Pawn",
                                  captured: target.pieceType,
                                  promotion: promo,
                                  castling: undefined,
                                  enPassant: false
                                });
                          }));
            } else {
              moves.push({
                    from: from,
                    to: to,
                    piece: "Pawn",
                    captured: target.pieceType,
                    promotion: undefined,
                    castling: undefined,
                    enPassant: false
                  });
              return ;
            }
          }
          
        }));
  var enPassantTarget = state.enPassantTarget;
  if (enPassantTarget !== undefined) {
    var expectedPawnRank = piece.color === "White" ? 4 : 3;
    if (rank === expectedPawnRank) {
      var offsets = [
        -1,
        1
      ];
      Belt_Array.forEach(offsets, (function (offset) {
              var adjacentSquare = from + offset | 0;
              var adjFile = Utils.modInt(adjacentSquare, 8);
              if (Utils.absInt(adjFile - file | 0) !== 1) {
                return ;
              }
              var targetPawn = getPiece(state, adjacentSquare);
              if (targetPawn !== undefined && targetPawn.pieceType === "Pawn" && targetPawn.color !== piece.color && enPassantTarget === (adjacentSquare + direction | 0)) {
                moves.push({
                      from: from,
                      to: enPassantTarget,
                      piece: "Pawn",
                      captured: "Pawn",
                      promotion: undefined,
                      castling: undefined,
                      enPassant: true
                    });
                return ;
              }
              
            }));
    }
    
  }
  return moves;
}

function generateKnightMoves(state, from, piece) {
  var moves = [];
  var offsets = [
    -17,
    -15,
    -10,
    -6,
    6,
    10,
    15,
    17
  ];
  var file = Utils.modInt(from, 8);
  Belt_Array.forEach(offsets, (function (offset) {
          var to = from + offset | 0;
          var toFile = Utils.modInt(to, 8);
          if (!(isValidSquare(to) && Utils.absInt(toFile - file | 0) <= 2)) {
            return ;
          }
          var target = getPiece(state, to);
          if (target !== undefined) {
            if (target.color !== piece.color) {
              moves.push({
                    from: from,
                    to: to,
                    piece: "Knight",
                    captured: target.pieceType,
                    promotion: undefined,
                    castling: undefined,
                    enPassant: false
                  });
              return ;
            } else {
              return ;
            }
          } else {
            moves.push({
                  from: from,
                  to: to,
                  piece: "Knight",
                  captured: undefined,
                  promotion: undefined,
                  castling: undefined,
                  enPassant: false
                });
            return ;
          }
        }));
  return moves;
}

function generateSlidingMoves(state, from, piece, directions, isDiagonal) {
  var moves = [];
  var file = Utils.modInt(from, 8);
  Belt_Array.forEach(directions, (function (direction) {
          var to = from + direction | 0;
          var prevFile = file;
          var running = true;
          while(running && isValidSquare(to)) {
            var toFile = Utils.modInt(to, 8);
            var exit = 0;
            if (isDiagonal !== undefined && isDiagonal) {
              if (Utils.absInt(toFile - prevFile | 0) !== 1) {
                running = false;
              }
              
            } else {
              exit = 1;
            }
            if (exit === 1 && (direction === -1 || direction === 1) && Utils.absInt(toFile - prevFile | 0) !== 1) {
              running = false;
            }
            if (running) {
              var target = getPiece(state, to);
              if (target !== undefined) {
                if (target.color !== piece.color) {
                  moves.push({
                        from: from,
                        to: to,
                        piece: piece.pieceType,
                        captured: target.pieceType,
                        promotion: undefined,
                        castling: undefined,
                        enPassant: false
                      });
                  running = false;
                } else {
                  running = false;
                }
              } else {
                moves.push({
                      from: from,
                      to: to,
                      piece: piece.pieceType,
                      captured: undefined,
                      promotion: undefined,
                      castling: undefined,
                      enPassant: false
                    });
              }
              if (running) {
                prevFile = toFile;
                to = to + direction | 0;
              }
              
            }
            
          };
        }));
  return moves;
}

function generateKingMoves(state, from, piece, includeCastling) {
  var moves = [];
  var offsets = [
    -9,
    -8,
    -7,
    -1,
    1,
    7,
    8,
    9
  ];
  var file = Utils.modInt(from, 8);
  Belt_Array.forEach(offsets, (function (offset) {
          var to = from + offset | 0;
          var toFile = Utils.modInt(to, 8);
          if (!(isValidSquare(to) && Utils.absInt(toFile - file | 0) <= 1)) {
            return ;
          }
          var target = getPiece(state, to);
          if (target !== undefined) {
            if (target.color !== piece.color) {
              moves.push({
                    from: from,
                    to: to,
                    piece: "King",
                    captured: target.pieceType,
                    promotion: undefined,
                    castling: undefined,
                    enPassant: false
                  });
              return ;
            } else {
              return ;
            }
          } else {
            moves.push({
                  from: from,
                  to: to,
                  piece: "King",
                  captured: undefined,
                  promotion: undefined,
                  castling: undefined,
                  enPassant: false
                });
            return ;
          }
        }));
  if (includeCastling) {
    var rights = state.castlingRights;
    if (piece.color === "White" && from === 4) {
      if (rights.whiteKingside && getPiece(state, 5) === undefined && getPiece(state, 6) === undefined) {
        var rook = getPiece(state, 7);
        if (rook !== undefined && rook.pieceType === "Rook" && !isSquareAttacked(state, 4, "Black") && !isSquareAttacked(state, 5, "Black") && !isSquareAttacked(state, 6, "Black")) {
          moves.push({
                from: 4,
                to: 6,
                piece: "King",
                captured: undefined,
                promotion: undefined,
                castling: "K",
                enPassant: false
              });
        }
        
      }
      if (rights.whiteQueenside && getPiece(state, 3) === undefined && getPiece(state, 2) === undefined && getPiece(state, 1) === undefined) {
        var rook$1 = getPiece(state, 0);
        if (rook$1 !== undefined && rook$1.pieceType === "Rook" && !isSquareAttacked(state, 4, "Black") && !isSquareAttacked(state, 3, "Black") && !isSquareAttacked(state, 2, "Black")) {
          moves.push({
                from: 4,
                to: 2,
                piece: "King",
                captured: undefined,
                promotion: undefined,
                castling: "Q",
                enPassant: false
              });
        }
        
      }
      
    } else if (piece.color === "Black" && from === 60) {
      if (rights.blackKingside && getPiece(state, 61) === undefined && getPiece(state, 62) === undefined) {
        var rook$2 = getPiece(state, 63);
        if (rook$2 !== undefined && rook$2.pieceType === "Rook" && !isSquareAttacked(state, 60, "White") && !isSquareAttacked(state, 61, "White") && !isSquareAttacked(state, 62, "White")) {
          moves.push({
                from: 60,
                to: 62,
                piece: "King",
                captured: undefined,
                promotion: undefined,
                castling: "k",
                enPassant: false
              });
        }
        
      }
      if (rights.blackQueenside && getPiece(state, 59) === undefined && getPiece(state, 58) === undefined && getPiece(state, 57) === undefined) {
        var rook$3 = getPiece(state, 56);
        if (rook$3 !== undefined && rook$3.pieceType === "Rook" && !isSquareAttacked(state, 60, "White") && !isSquareAttacked(state, 59, "White") && !isSquareAttacked(state, 58, "White")) {
          moves.push({
                from: 60,
                to: 58,
                piece: "King",
                captured: undefined,
                promotion: undefined,
                castling: "q",
                enPassant: false
              });
        }
        
      }
      
    }
    
  }
  return moves;
}

function isSquareAttacked(state, targetSquare, byColor) {
  var attacked = false;
  for(var square = 0; square <= 63; ++square){
    if (!attacked) {
      var piece = getPiece(state, square);
      if (piece !== undefined && piece.color === byColor) {
        var match = piece.pieceType;
        var moves;
        switch (match) {
          case "Pawn" :
              moves = generatePawnMoves(state, square, piece);
              break;
          case "Knight" :
              moves = generateKnightMoves(state, square, piece);
              break;
          case "Bishop" :
              moves = generateSlidingMoves(state, square, piece, [
                    -9,
                    -7,
                    7,
                    9
                  ], true);
              break;
          case "Rook" :
              moves = generateSlidingMoves(state, square, piece, [
                    -8,
                    -1,
                    1,
                    8
                  ], false);
              break;
          case "Queen" :
              moves = generateSlidingMoves(state, square, piece, [
                    -9,
                    -8,
                    -7,
                    -1,
                    1,
                    7,
                    8,
                    9
                  ], undefined);
              break;
          case "King" :
              moves = generateKingMoves(state, square, piece, false);
              break;
          
        }
        if (Belt_Array.some(moves, (function (move) {
                  return move.to === targetSquare;
                }))) {
          attacked = true;
        }
        
      }
      
    }
    
  }
  return attacked;
}

function generatePieceMoves(state, from, piece) {
  var match = piece.pieceType;
  switch (match) {
    case "Pawn" :
        return generatePawnMoves(state, from, piece);
    case "Knight" :
        return generateKnightMoves(state, from, piece);
    case "Bishop" :
        return generateSlidingMoves(state, from, piece, [
                    -9,
                    -7,
                    7,
                    9
                  ], true);
    case "Rook" :
        return generateSlidingMoves(state, from, piece, [
                    -8,
                    -1,
                    1,
                    8
                  ], false);
    case "Queen" :
        return generateSlidingMoves(state, from, piece, [
                    -9,
                    -8,
                    -7,
                    -1,
                    1,
                    7,
                    8,
                    9
                  ], undefined);
    case "King" :
        return generateKingMoves(state, from, piece, true);
    
  }
}

function generateAllMoves(state, color) {
  var moves = [];
  for(var square = 0; square <= 63; ++square){
    var piece = getPiece(state, square);
    if (piece !== undefined && piece.color === color) {
      var pieceMoves = generatePieceMoves(state, square, piece);
      Belt_Array.forEach(pieceMoves, (function (move) {
              moves.push(move);
            }));
    }
    
  }
  return moves;
}

function isKingInCheck(state, color) {
  var kingSquare;
  for(var square = 0; square <= 63; ++square){
    if (kingSquare === undefined) {
      var piece = getPiece(state, square);
      if (piece !== undefined && piece.color === color && piece.pieceType === "King") {
        kingSquare = square;
      }
      
    }
    
  }
  var square$1 = kingSquare;
  if (square$1 !== undefined) {
    return isSquareAttacked(state, square$1, Utils.oppositeColor(color));
  } else {
    return false;
  }
}

function makeMove(state, move) {
  var piece = getPiece(state, move.from);
  if (piece === undefined) {
    return state;
  }
  var board = state.board.slice(0);
  var hash = state.zobristHash;
  hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(piece)), move.from));
  var capturedType = move.captured;
  if (capturedType !== undefined) {
    var capturedColor = Utils.oppositeColor(piece.color);
    var capturedPiece = {
      pieceType: capturedType,
      color: capturedColor
    };
    if (move.enPassant) {
      var capturedPawnSquare = move.to + (
        piece.color === "White" ? -8 : 8
      ) | 0;
      hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(capturedPiece)), capturedPawnSquare));
      Belt_Array.setExn(board, capturedPawnSquare, undefined);
    } else {
      hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(capturedPiece)), move.to));
    }
  }
  var promo = move.promotion;
  var finalPiece = promo !== undefined ? ({
        pieceType: promo,
        color: piece.color
      }) : piece;
  hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(finalPiece)), move.to));
  Belt_Array.setExn(board, move.to, finalPiece);
  Belt_Array.setExn(board, move.from, undefined);
  var match = move.castling;
  if (match !== undefined) {
    switch (match) {
      case "K" :
          var rook = Belt_Option.getExn(getPiece(state, 7));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook)), 7));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook)), 5));
          Belt_Array.setExn(board, 5, rook);
          Belt_Array.setExn(board, 7, undefined);
          break;
      case "Q" :
          var rook$1 = Belt_Option.getExn(getPiece(state, 0));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$1)), 0));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$1)), 3));
          Belt_Array.setExn(board, 3, rook$1);
          Belt_Array.setExn(board, 0, undefined);
          break;
      case "k" :
          var rook$2 = Belt_Option.getExn(getPiece(state, 63));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$2)), 63));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$2)), 61));
          Belt_Array.setExn(board, 61, rook$2);
          Belt_Array.setExn(board, 63, undefined);
          break;
      case "q" :
          var rook$3 = Belt_Option.getExn(getPiece(state, 56));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$3)), 56));
          hash = Zobrist.xor(hash, Caml_array.get(Caml_array.get(Zobrist.globalKeys.pieces, Zobrist.getPieceIndex(rook$3)), 59));
          Belt_Array.setExn(board, 59, rook$3);
          Belt_Array.setExn(board, 56, undefined);
          break;
      default:
        
    }
  }
  var rights = state.castlingRights;
  if (rights.whiteKingside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 0));
  }
  if (rights.whiteQueenside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 1));
  }
  if (rights.blackKingside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 2));
  }
  if (rights.blackQueenside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 3));
  }
  var match$1 = piece.pieceType;
  var newRights;
  switch (match$1) {
    case "Rook" :
        newRights = piece.color === "White" ? (
            move.from === 0 ? ({
                  whiteKingside: rights.whiteKingside,
                  whiteQueenside: false,
                  blackKingside: rights.blackKingside,
                  blackQueenside: rights.blackQueenside
                }) : (
                move.from === 7 ? ({
                      whiteKingside: false,
                      whiteQueenside: rights.whiteQueenside,
                      blackKingside: rights.blackKingside,
                      blackQueenside: rights.blackQueenside
                    }) : rights
              )
          ) : (
            move.from === 56 ? ({
                  whiteKingside: rights.whiteKingside,
                  whiteQueenside: rights.whiteQueenside,
                  blackKingside: rights.blackKingside,
                  blackQueenside: false
                }) : (
                move.from === 63 ? ({
                      whiteKingside: rights.whiteKingside,
                      whiteQueenside: rights.whiteQueenside,
                      blackKingside: false,
                      blackQueenside: rights.blackQueenside
                    }) : rights
              )
          );
        break;
    case "King" :
        newRights = piece.color === "White" ? ({
              whiteKingside: false,
              whiteQueenside: false,
              blackKingside: rights.blackKingside,
              blackQueenside: rights.blackQueenside
            }) : ({
              whiteKingside: rights.whiteKingside,
              whiteQueenside: rights.whiteQueenside,
              blackKingside: false,
              blackQueenside: false
            });
        break;
    default:
      newRights = rights;
  }
  var finalRights = move.to === 0 ? ({
        whiteKingside: newRights.whiteKingside,
        whiteQueenside: false,
        blackKingside: newRights.blackKingside,
        blackQueenside: newRights.blackQueenside
      }) : (
      move.to === 7 ? ({
            whiteKingside: false,
            whiteQueenside: newRights.whiteQueenside,
            blackKingside: newRights.blackKingside,
            blackQueenside: newRights.blackQueenside
          }) : (
          move.to === 56 ? ({
                whiteKingside: newRights.whiteKingside,
                whiteQueenside: newRights.whiteQueenside,
                blackKingside: newRights.blackKingside,
                blackQueenside: false
              }) : (
              move.to === 63 ? ({
                    whiteKingside: newRights.whiteKingside,
                    whiteQueenside: newRights.whiteQueenside,
                    blackKingside: false,
                    blackQueenside: newRights.blackQueenside
                  }) : newRights
            )
        )
    );
  if (finalRights.whiteKingside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 0));
  }
  if (finalRights.whiteQueenside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 1));
  }
  if (finalRights.blackKingside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 2));
  }
  if (finalRights.blackQueenside) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.castling, 3));
  }
  var sq = state.enPassantTarget;
  if (sq !== undefined) {
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.enPassant, Utils.modInt(sq, 8)));
  }
  var enPassantTarget;
  if (piece.pieceType === "Pawn" && Utils.absInt(move.to - move.from | 0) === 16) {
    var epSq = (move.from + move.to | 0) / 2 | 0;
    hash = Zobrist.xor(hash, Caml_array.get(Zobrist.globalKeys.enPassant, Utils.modInt(epSq, 8)));
    enPassantTarget = epSq;
  } else {
    enPassantTarget = undefined;
  }
  hash = Zobrist.xor(hash, Zobrist.globalKeys.sideToMove);
  var halfmoveClock = piece.pieceType === "Pawn" || move.captured !== undefined ? 0 : state.halfmoveClock + 1 | 0;
  var fullmoveNumber = piece.color === "Black" ? state.fullmoveNumber + 1 | 0 : state.fullmoveNumber;
  var newTurn = Utils.oppositeColor(state.turn);
  var moveHistory = Belt_Array.concat(state.moveHistory, [move]);
  var positionHistory = Belt_Array.concat(state.positionHistory, [state.zobristHash]);
  var irreversibleHistory = Belt_Array.concat(state.irreversibleHistory, [{
          castlingRights: state.castlingRights,
          enPassantTarget: state.enPassantTarget,
          halfmoveClock: state.halfmoveClock,
          zobristHash: state.zobristHash
        }]);
  return {
          board: board,
          turn: newTurn,
          castlingRights: finalRights,
          enPassantTarget: enPassantTarget,
          halfmoveClock: halfmoveClock,
          fullmoveNumber: fullmoveNumber,
          moveHistory: moveHistory,
          zobristHash: hash,
          positionHistory: positionHistory,
          irreversibleHistory: irreversibleHistory
        };
}

function generateLegalMoves(state) {
  var moves = generateAllMoves(state, state.turn);
  return Belt_Array.keep(moves, (function (move) {
                var nextState = makeMove(state, move);
                return !isKingInCheck(nextState, state.turn);
              }));
}

export {
  isValidSquare ,
  getPiece ,
  generatePawnMoves ,
  generateKnightMoves ,
  generateSlidingMoves ,
  generateKingMoves ,
  isSquareAttacked ,
  generatePieceMoves ,
  generateAllMoves ,
  isKingInCheck ,
  makeMove ,
  generateLegalMoves ,
}
/* Zobrist Not a pure module */
